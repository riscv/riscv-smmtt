[[chapter6]]
[[IO-MPT]]
== I/O MPT extension

Supervisor domains may be granted control over DMA-capable devices. When such
direct device association is supported, the system might also incorporate
multiple instances of IOMMU. Each IOMMU instance can be tied directly to a
supervisor domain, allowing that domain to manage address translation
and protection for DMA that originates from devices under its control.

To uphold isolation properties, the DMA from the devices and the IOMMU
linked with a supervisor domain must adhere strictly to the access protections
encoded in the MPT of the respective supervisor domain. Additionally, using the
MPT, the RDSM enforces that the IOMMU memory-mapped programming regions are
access-restricted to the supervisor domain the IOMMU is assigned to.

At any given time, a solitary supervisor domain is scheduled for execution on a
RISC-V hart by the root domain security manager (RDSM). As part of this
scheduling, the RDSM programs a pointer to the MPT into a CSR within the hart.
Unlike the RISC-V harts, DMA-capable devices connected to a supervisor domain
remain continuously active. Such devices might initiate DMA even if the
associated domain is not currently active on any RISC-V harts. As a result, the
MPT of all supervisor domains must be constantly active for DMA protection.
Furthermore, the IO subsystem must possess the capability to select the
appropriate MPT for enforcement based on the identity of the device initiating
the DMA.

Given this setup, the I/O subsystem is required to offer the following
functions:

* Supervisor Domain Classifier (SDCL): This classifier within the I/O subsystem
  interprets the attributes of a DMA request and determines the appropriate MPT
  for that request.

* MPT Checker (MPTCHK): This function ensures that stipulated access controls by
  `Smmpt` are applied to the memory regions accessed by the DMA. It uses the MPT
  identified by the SDCL.

Collectively, these two functionalities form a logical block in the I/O
subsystem, referred to as the I/O MPT checker.

=== Placement of I/O MPT checker

The IO Bridge serves as an intermediary, situated between the IO devices and the
system interconnect, with the primary role of processing DMA transactions. These
IO devices can initiate DMA transactions utilizing IO Virtual Addresses (IOVA).
Notably, an IOVA could be in the form of a Virtual Address (VA), Guest Virtual
Address (GVA), or Guest Physical Address (GPA). The configuration and
interfacing of the I/O MPT Checker with respect to the IO Bridge is graphically
represented in <<io-mpt-checker>>.

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title= "I/O MPT checker placement", id=io-mpt-checker]
image::images/IOMTTCHK.png[width=800]
[[fig:IOMPTCHK]]

The IO Bridge invokes the SDCL function using the SDID request interface (SDR)
and provides it the identifiers associated with the incoming transaction. The
SDCL classifies the request using the identifiers and provides the IOSDID and
the IOMMU ID on the SDID completion interface (SDC).

The IO Bridge uses the IOMMU ID to determine the IOMMU governing this request.
The IO Bridge uses the device translation request (DTR) interface to the
selected IOMMU to request address translation. The selected IOMMU provides the
response to the address translation request on the device translation completion
(DTC) interface. As part of the address translation process, the IOMMU may need
to access its in-memory data structures over its data structure interface (DSI).

The IO Bridge invokes the MPTCHK function over the MPT check request (MCR)
interface and provides it the IOSDID and physical address of the access. The
MPTCHK uses the IOSDID to determine the MPT associated with the supervisor
domain and checks if the physical address may be accessed by the device or IOMMU
associated with that supervisor domain. The result of the check is provided on
the MPT check completion (MCC) interface to the IO Bridge. As part of the MPT
check, the MPTCHK may need to perform implicit accesses to the MPT using the MPT
walk interface (MWI). To perform the checks the MPTCHK uses the same MPT table
format as used by the CPU's MMU. Using the same MPT table formats as the CPU's
MMU allows the same table to be used simultaneously by the CPU MMU and MPTCHK.
The MPT access permission lookup process used by MPTCHK is identical to that
specified by `Smmpt` extension in section "MPT access permissions lookup process".

The RISC-V memory model requires memory access from a hart to be single-copy
atomic. When RV32 is implemented the size of a single-copy atomic memory access
is up to 32-bits. When RV64 is implemented the size of a single-copy atomic
memory access is up to 64-bits. The size of a single-copy atomic memory access
implemented by MPTCHK is UNSPECIFIED but is required to be at least 32-bits if
all of the harts in the system implement RV32 and is required to be at least
64-bits if any of the harts in the system implement RV64. Software must follow
the rules outlined below to update MPT entries.

* It is generally unsafe to update fields of an MPT entry using stores of width
  less than the minimal single-copy atomic memory access supported by MPTCHK as
  it is legal for MPTCHK to read the entry at any time, including when only
  some of the partial stores have taken effect. For an update to be atomic,
  software must use a single store of width equal to the minimal single-copy
  atomic memory access supported by MPTCHK.

* MPTCHK is not required to immediately observe the software updates to an MPT
  entry. Software must use the `MPTINVAL` operation outlined in <<CTRL>> to
  invalidate any previous copies of that entry that may be in the MPTCHK caches
  to synchronize the updates to the entry with the operation of MPTCHK.

[NOTE]
====
If an MPT entry is changed, MPTCHK may use the old value of the entry or the
new value of the entry and the choice is unpredictable until software uses the
`MPTINVAL` operation to synchronize updates to the entry with the operation of
the MPTCHK. These are the only behaviors expected.
====

The I/O MPT checker provides a memory-mapped register programming interface.

If an MPT check disallows a transaction then the transaction is aborted.

If the aborted transaction is an IOMMU-initiated memory access then the IO bridge
signals such access faults to the IOMMU itself. The details of such signaling is
implementation defined.

If the aborted transaction is a write then the IO bridge may discard the write;
the details of how the write is discarded are implementation defined. If the IO
protocol requires a response for write transactions (e.g., AXI) then a response
as defined by the IO protocol may be generated by the IO bridge (e.g., SLVERR on
BRESP - Write Response channel). For PCIe, for example, write transactions are
posted and no response is returned when a write transaction is discarded. If the
faulting transaction is a read then the device expects a completion. The IO
bridge may provide a completion to the device. The data, if returned, in such
completion is implementation defined; usually it is a fixed value such as all 0
or all 1. A status code may be returned to the device in the completion to
indicate this condition. For AXI, for example, the completion status is provided
by SLVERR on RRESP (Read Data channel). For PCIe, for example, the completion
status field may be set to "Unsupported Request" (UR) or "Completer Abort" (CA).

As part of its operations, MPTCHK may need to read data from the MPT. The
provider (a memory controller or a cache) of the data may detect that the data
requested has an uncorrectable error and signal that the data is corrupted and
defer the error to MPTCHK. Such technique to defer the handling of the corrupted
data to the consumer of the data is also commonly known as data poisoning. The
effects of such errors may be contained to the transaction that caused the
corrupted data to be accessed. In the cases where the error affects the
transaction being processed but otherwise allows the MPTCHK to continue providing
service, MPTCHK may request the IO bridge to abort the transaction. The MPTCHK
may support the RISC-V RAS error record register interface (RERI) that specifies
methods for enabling error detection, logging the detected errors, and
configuring means to report the error to an error handler. When such a RAS
architecture is supported, errors such as attempted consumption of poisoned data
may be reported using the methods provided by the RAS architecture.

A supervisor domain, identified by an SDID, may be associated with one or more
IOMMU instances that are each identified by an IOMMU ID. A given IOMMU ID
however can only be associated with one supervisor domain.

[NOTE]
====
Usually an IOMMU is associated with an I/O port, and an I/O port connects to one
or more devices that are governed by that IOMMU. An I/O MPT checker may be
associated with more than one I/O port. A supervisor domain may be associated
with one or more devices from each of these I/O ports, necessitating the
association of an IOMMU instance for each I/O port to be used by that supervisor
domain. When a common I/O MPT checker is used to check I/O originating from
multiple I/O ports, the SDCL may be configured with rules to classify a device
connected to an I/O port as associated with a supervisor domain and with the
IOMMU instance that governs that device.
====

To support I/O MPT checks, the RDSM provides two types of configurations to the
I/O MPT checker:

* SDCL rules that classify one or more devices to an SDID and an IOMMU ID.

* Configurations that determine the MPT used to check memory requests
  originated by the IOMMUs and devices associated with that SDID, and
  configurations that determine the QoS IDs carried with such memory requests.

These configurations are programmed through the I/O MPT checker register
interface.

=== I/O MPT Checker Register Interface

Each I/O MPT checker (IOMPTCHK) register interface is memory-mapped starting at
an 8-byte aligned physical address and includes the registers used to configure
the SDCL and MPTCHK functions in the I/O MPT checker.

[NOTE]
====
Implementations may choose to implement a coarser alignment for the start
address of the register interface. For example, some implementations may locate
the register interface within a naturally aligned 4-KiB region (a page) of
physical address space for each register interface. Coarser alignments may
enable register decoding to be implemented without a hardware adder circuit.
====

The behavior for register accesses where the address is not aligned to
the size of the access, or if the access spans multiple registers, or if the
size of the access is not 4 bytes or 8 bytes, is `UNSPECIFIED`. An aligned 4
byte access to a IOMPTCHK register must be single-copy atomic. Whether an 8 byte
access to an IOMPTCHK register is single-copy atomic is `UNSPECIFIED`, and such
an access may appear, internally to the IOMPTCHK implementation, as if two
separate 4 byte accesses were performed.

[NOTE]
====
The IOMPTCHK registers are defined in such a way that software can perform two
individual 4 byte accesses, or hardware can perform two independent 4 byte
transactions resulting from an 8 byte access, to the high and low halves of the
register as long as the register semantics, with regards to side-effects, are
respected between the two software accesses, or two hardware transactions,
respectively.
====

The IOMPTCHK registers have little-endian byte order (even for systems where
all harts are big-endian-only).

[NOTE]
====
Big-endian-configured harts that make use of I/O MPT may implement the `REV8`
byte-reversal instruction defined by the Zbb extension. If `REV8` is not
implemented, then endianness conversion may be implemented using a sequence
of instructions.
====

.I/O MPT Checker register layout
[width=100%]
[%header, cols="^3,10,^3, 18, 5"]
|===
|Offset|Name           |Size    |Description                | Optional?
|0     |`capabilities` |8       |<<CAP,  Capabilities   >>  | No
|4     |`control`      |4       |<<CTRL, Control        >>  | No
|8     |`status`       |4       |<<STS,  Status         >>  | No
|16    |`data-0`       |8       |<< Input/Output data 0 >>  | No
|24    |`data-1`       |8       |<< Input/Output data 1 >>  | No
|32    |`data-2`       |8       |<< Input/Output data 2 >>  | Yes
|===

The reset value is 0 for the following registers fields.

* `status` - `BUSY` and `STATUS` fields

The reset value is `UNSPECIFIED` for all other registers and/or fields.

[[CAP]]
=== Capabilities (`capabilities`)

The `capabilities` register is a read-only register that holds the I/O MPT
checker capabilities.

[caption="Register {counter:rimage}: ", reftext="Register {rimage}"]
[title="Capabilities register fields"]
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'VER'},
  {bits:  1, name: 'MPTM'},
  {bits:  1, name: 'QOSID'},
  {bits: 38, name: 'WPRI'},
  {bits: 16, name: 'custom'}
], config:{lanes: 4, hspace:1024}}
....

The `VER` field holds the version of the specification implemented by the
I/O MPT checker. The low nibble is used to hold the minor version of the
specification and the upper nibble is used to hold the major version of the
specification. For example, an implementation that supports version 1.0 of the
specification reports 0x10.

The `MPTM` field indicates the supported MPT address protection schemes. If 1,
then the MPT modes for RV64 are supported else the MPT modes for RV32 are
supported.

The `QOSID` field indicates whether associating QoS IDs with requests is
supported; if set to 1, the QoS ID related fields in `data-2` are
implemented, otherwise these fields are reserved and read-only zero.

[[CTRL]]
=== Control register (`control`)

The `control` register is used to initiate I/O MPT checker operations. The
specific operation is identified by the `OP` field within the `control`
register. Operands required to complete the operation are supplied either in
dedicated fields of the `control` register or in one or more of the associated
`data-*` registers.  The `OP` field also defines the encoding of the
`data` fields in the `control` register and of the `data-*` registers for
that operation.

.Control Register (`control`)
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits: 24, name: 'operands (WARL)'},
], config:{lanes: 8, hspace:1024}}
....

[[IOMPTCHK_OP]]
.I/O MPT checker operations (`OP`)
[width=100%]
[%header, cols="16,^12,70"]
|===
| Operation         | Encoding ^| Description
| --                | 0         | Reserved for future standard use.
| `SET_SDCL_ENTRY`  | 1         | Configure a rule in the SDCL.
| `GET_SDCL_ENTRY`  | 2         | Read the configuration of an SDCL rule.
| `SET_SDCFG_ENTRY` | 3         | Configure MPT and QoS ID parameters for an SD.
| `GET_SDCFG_ENTRY` | 4         | Read the configuration associated with an SD.
| `MPTINVAL`        | 5         | Ensure that stores to an MPT are observed by
                                  MPTCHK before subsequent implicit reads by
                                  MPTCHK to the corresponding MPT.
| `IOFENCE`         | 6         | Ensure that all previous read and write
                                  requests from devices already processed by
                                  IOMPTCHK are committed to a global ordering
                                  point such that they can be observed by all
                                  RISC-V harts, IOMMUs, and devices in the
                                  system.
| --                | 7–127     | Reserved for future standard use.
| --                | 128–255   | Designated for custom use.
|===

Before requesting an operation using the `control` register, software must
program the fields of the `data-0`, `data-1`, and `data-2` registers as
required by that operation. Fields not used by an operation are ignored.

[[STS]]
=== Status register (`status`)

The `status` register provides the status of the operation requested using the
`control` register.

.Status Register (`control`)
....
{reg: [
  {bits:  7, name: 'STATUS (RO)'},
  {bits: 23, name: 'WPRI'},
  {bits:  1, name: 'BUSY (RO)'}
], config:{lanes: 8, hspace:1024}}
....

When the `control` register is written, IOMPTCHK may perform actions that do not
complete synchronously with the write. A write to the `control` register sets
the `status.BUSY` bit to 1, indicating that IOMPTCHK is executing the requested
operation. The behavior of writing the `control` or the `data-*` registers
while the `status.BUSY` bit is 1 is `UNSPECIFIED`. Some implementations may
ignore the second write, while others may perform the operation specified by
that write. Software must verify that `BUSY` is 0 before writing to the
`control` or `data-*` registers.

[NOTE]
====
An implementation that always completes the requested operation synchronously
with a write to the `control` register may hardwire the `BUSY` bit to 0.
====

When the `status.BUSY` bit reads 0, the operation is complete, and the
`status.STATUS_CODE` field provides a status value (<<IOMPTCHK_STS>>) for the
requested operation.

[[IOMPTCHK_STS]]
.`control.STATUS` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`STATUS` | Description
| 0       | Reserved.
| 1       | Operation completed successfully.
| 2       | Invalid operation (`OP`) requested.
| 3       | Operation requested for invalid `RULEID`.
| 4       | Operation requested for invalid `SDID`.
| 5       | Illegal or invalid operand encodings.
| 6-127   | Reserved for future standard use.
| 128-255 | Designated for custom use.
|===

=== Configure a rule in the SDCL - `SET_SDCL_ENTRY`

The `SET_SDCL_ENTRY` operation configures an SDCL rule to classify DMA requests
based on the identifiers associated with the requests, in order to determine the
supervisor domain ID (`SDID`) and the IOMMU ID (`IOMMU_ID`).

This operation uses the operands in the `control` register and the `data-0`
register. The contents of the `data-1` and `data-2` registers are ignored
by this operation.

For this operation, the fields of the `control` and `data-0` registers are
interpreted as follows.

.`control` register layout for `SET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  8, name: 'RULEID (WARL)'},
  {bits: 16, name: 'WPRI'},
  {bits:  7, name: 'STATUS (RO)'},
  {bits:  1, name: 'BUSY (RO)'},
  {bits: 24, name: 'WPRI'}
], config:{lanes: 8, hspace:1024}}
....

.`data-0` register layout for `SET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'SRC_IDT (WARL)'},
  {bits:  2, name: 'SRC_IDM (WARL)'},
  {bits:  2, name: 'TEE_FLT (WARL)'},
  {bits: 24, name: 'SRC_ID'},
  {bits:  8, name: 'IOMMU_ID (WARL)'},
  {bits:  8, name: 'SDID (WARL)'},
  {bits: 16, name: 'WPRI'}
], config:{lanes: 8, hspace:1024}}
....

The `SRC_IDT` field identifies the type of identifier from the DMA transaction
used by this classification rule. The `SRC_IDT` encodings are listed in
<<SRC_IDT>>.

[[SRC_IDT]]
.`data-0.SRC_IDT` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`SRC_IDT` | Description
|    0     | None. This rule does not match any incoming transaction. All other
             fields of the `data-0` register are ignored.
|    1     | Filter by device ID. The device ID is specified in `SRC_ID` field.
|    2     | Filter by PCIe IDE stream ID and PCIe segment ID. The IDE stream ID
             is specified in the bits 7:0 of the `SRC_ID` field and the segment
             ID in bits 15:8 of the `SRC_ID`. The bits 23:16 of the `SRC_ID`
             field are ignored.
|  3 - 7   | Reserved for future standard use.
|  8 - 15  | Designated for custom use.
|===

[NOTE]
====
In PCIe systems, an originating device can be pinpointed using a unique 16-bit
identifier. This identifier is a composite of the PCI bus number (8 bits),
device number (5 bits), and function number (3 bits), collectively referred to
as the routing identifier or RID. In scenarios where an IOMMU manages multiple
hierarchies, there's also an optional segment number, which can be up to 8 bits.
Each hierarchy in this context represents a distinct PCI Express I/O
interconnect topology. Here, the Configuration Space addresses, which are
delineated by the Bus, Device, and Function number tuple, remain distinct.
Sometimes, the term Hierarchy is synonymous with Segment. Especially when in
Flit Mode, the Segment number can be part of a Function's ID.
====

The `SRC_IDM` field can configure `SRC_ID` matching mode for transactions. The
`SRC_IDM` encodings are listed in <<SRC_IDM>>.

[[SRC_IDM]]
.data-0.SRC_IDM field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`SRC_IDM` | Description
|    0     | Reserved for future standard use.
|    1     | Unary. If Unary is selected, then this rule matches if all the bits
             of the source ID of the transaction match the value configured in
             the `SRC_ID` field.
|    2     | NAPOT. If NAPOT is selected, then the rule matches a naturally
             aligned power-of-two range of source IDs. In this mode, the lower
             bits of the `SRC_ID`, up to and including the first low-order zero
             bit, are masked; the unmasked bits are compared with the
             corresponding bits in the source ID of the transaction to match.
|    3     | TOR. If TOR (Top-Of-Range) is selected, the `SRC_ID` field
             forms the top of a range of source IDs. If rule __r__'s `SRC_IDM`
             is set to TOR, the rule matches any source ID __s__ if: __s__ is
             greater than or equal to `SRC_ID` of rule __r-1__ and is less than
             the `SRC_ID` of rule __r__. If __r__ is 0, then zero is used as the
             lower bound. If `SRC_ID` of rule __r-1__ is greater than or equal
             to that of rule __r__ and TOR is selected for rule __r__, then rule
             __r__ does not match any address.
|===

[NOTE]
====
The following example illustrates the use of `SRC_IDM=NAPOT` when `SRC_IDT` is
by `DEVID` and a 24-bit PCIe `device_id` comprised of the segment, bus, device,
and function number is used. In the table below, `y` acts as a placeholder
representing any 1-bit value.

.`SRC_IDM` with `SRC_IDT` set to Filter by device ID
[cols="^1,3,3", options="header"]
|===
| `SRC_IDM` | `SRC_ID`                     | *Comment*
| 1         |`yyyyyyyy  yyyyyyyy  yyyyyyyy`| One specific seg:bus:dev:func
| 2         |`yyyyyyyy  yyyyyyyy  yyyyy011`| seg:bus:dev - any func
| 2         |`yyyyyyyy  yyyyyyyy  01111111`| seg:bus - any dev:func
| 2         |`yyyyyyyy  01111111  11111111`| seg - any bus:dev:func
|===

====

The `TEE_FLT` field may be used to filter transactions associated with a Trusted
Execution Environment (TEE). The encodings for the `TEE_FLT` field can be found
in <<TEE_FLT>>.

[[TEE_FLT]]
.`data-0.TEE_FLT` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`TEE_FLT` | Description
|   0      | Reserved for future standard use.
|   1      | Rule matches TEE-associated transactions.
|   2      | Rule matches transactions that are not TEE associated.
|   3      | Rule matches both TEE-associated and non-TEE associated
             transactions.
|===

[NOTE]
====
PCIe IDE provides security for transactions from one Port to another. These
transactions might be initiated by contexts within the device, such as an SR-IOV
virtual function, which are associated with a Trusted Execution Environment
(TEE). Within the IDE TLP header, there's a "T" bit that helps differentiate
transactions related to a TEE. The `TEE_FLT` filter can be employed to associate
these TEE-related transactions with a different supervisor domain than the
transactions not related to TEE. This distinction is made even if both types of
transactions are received on the same PCIe IDE stream.

Fields such as `TEE_FLT` and `IOMMU_ID` are WARL and may be hardwired to 0 if
the implementation does not support PCIe IDE and/or an IOMMU.
====

The `IOMMU_ID` field identifies the instance of the IOMMU that should be used to
provide address translation and protection for the transactions matching this
rule.

The `SDID` field identifies the supervisor domain whose memory is accessed by
this transaction.

=== Read the configuration of an SDCL rule - `GET_SDCL_ENTRY`

The `GET_SDCL_ENTRY` operation reads the configuration of an SDCL rule
identified by `RULEID`.  This operation ignores the contents of the `data-*`
registers. Upon a successful `GET_SDCL_ENTRY` operation, the configuration of
the rule identified by `control.RULEID` is returned in the `data-0` register.

The contents of the `data-0` register are `UNSPECIFIED` if the operation
fails or if it is invoked without a preceding `SET_SDCL_ENTRY` for the specified
`RULEID`. The contents of the `data-1` and `data-2` registers, whether the
operation completes successfully or not, are `UNSPECIFIED`.

For this operation, the fields of the `control` and `data-0` registers are
interpreted as follows.

.`control` register layout for `GET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  8, name: 'RULEID (WARL)'},
  {bits: 16, name: 'WPRI'},
], config:{lanes: 8, hspace:1024}}
....

.`data-0` register layout for `GET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'SRC_IDT'},
  {bits:  2, name: 'SRC_IDM'},
  {bits:  2, name: 'TEE_FLT'},
  {bits: 24, name: 'SRC_ID'},
  {bits:  8, name: 'IOMMU_ID'},
  {bits:  8, name: 'SDID'},
  {bits: 16, name: 'WPRI'}
], config:{lanes: 8, hspace:1024}}
....

[[OP-1]]
=== Operand 1 register (`operand-1`)

The `operand-1` register holds the input operands or the output results of
operations requested through `control.OP`.

[caption="Register {counter:rimage}: ", reftext="Register {rimage}"]
[title="Operand-1 register (`operand-1`)"]
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'MPT_MODE (WARL)'},
  {bits:  1, name: 'PPNV (WARL)'},
  {bits:  1, name: 'S (WARL)'},
  {bits:  1, name: 'IOSDIDV'},
  {bits:  3, name: 'WPRI'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'WPRI'}
], config:{lanes: 8, hspace:1024}}
....

The `MPT_MODE` field identifies the mode of the MPT. It's interpreted as
outlined in <<mpt-32>> when `capabilities.MPTM` is 1, and as detailed in
<<mpt-64>> otherwise. The `MPT_MODE` field is programmed into the rule
identified by `RULEID` via the `SET_ENTRY` operation and can be retrieved by
the `GET_ENTRY` operation. Both the `IOFENCE` and `MPTINVAL` operations
disregard the `MPT_MODE` field.

The `PPN` field programs the PPN of the root page of the MPT during the
`SET_ENTRY` operation and is retrieved by the `GET_ENTRY` operation. When
`MPT_MODE` is `Bare`, the `SET_ENTRY` operations requires the `PPN` field to be
zero. The `IOFENCE` operation disregards this field.

For the `MPTINVAL` operation, the `PPNV` field indicates if the `PPN` field is
valid and the `IOSDIDV` field indicates if the `IOSDID` field is valid for the
operation. When a field is not valid for an operation, it is ignored by the
operation. When the `PPNV` field is 1, the `S` field sets the address range size
for the `MPTINVAL` operation. With an `S` field value of 0, the range size is
4 KiB. But, when the `S` field has a value of 1, the `MPTINVAL` operation
focuses on a NAPOT range. This range is decided by the low-order bits of the
`PPN` field, going up to the first low-order 0 bit (inclusive of this position).
If the initial low-order 0 bit position is denoted as `x`, the size of the range
is computed as `(1 << (12 + x + 1))`. When `PPNV` is set to 1, if the address
range specified by `PPN` and `S` is invalid, the operation may or may not be
performed. If the `PPNV` and `S` are both set to 1 and all bits of the `PPN`
operand are 1, the behavior of `MPTINVAL` operation is UNSPECIFIED. Operations
besides `MPTINVAL` disregard the `PPNV` field.

The `MPTINVAL` operation ensures that stores to the MPT are observed by MPTCHK
before subsequent implicit reads by MPTCHK to the corresponding MPT.

. `MPTINVAL` operands and operations
[%autowidth,float="center",align="center"]
[%header, cols="^2,^2,20"]
|===
| `PPNV` | `IOSDIDV` | Operation
|   0    |  0        | Invalidates information cached from any MPT for all
                       supervisor domain address spaces.
|   0    |  1        | Invalidates information cached from the MPT for the
                       address space of the supervisor domain identified by
                       the `IOSDID` operand.
|   1    |  0        | Invalidates information cached from the MPT for the
                       address range in the `PPN` operand for all supervisor
                       domain address spaces.
|   1    |  1        | Invalidates information cached from the MPT for the
                       address range in the `PPN` operand for the supervisor
                       domain address space identified by the `IOSDID` operand.
|===


[NOTE]
====
The following example illustrates the use of `S` field to specify an address
range for the `MPTINVAL` operation. The example shows encoding ranges of up to
8 GiB. Larger ranges may be encoded using the upper address bits (bits 43:22)
of the `PPN` field.

. Examples of specifying address range sizes using `S` field
[cols="3,1,3", options="header"]
|===
| `PPN[21:0]`              | `S` | *Address Range Size*
| `yyyyy yyyyyyyy yyyyyyyy`|  0  | 4  KiB
| `yyyyy yyyyyyyy yyyyyyy0`|  1  | 8  KiB
| `yyyyy yyyyyyy0 11111111`|  1  | 2  MiB
| `yyy01 11111111 11111111`|  1  | 1  GiB
| `01111 11111111 11111111`|  1  | 8  GiB
|===

====

[NOTE]
====
Simpler implementations may ignore the operands of `MPTINVAL` operation and
perform a global invalidation of all information cached from any MPT.

A consequence of this specification is that an implementation may use any
information for an address that was valid in the MPT at any time since the most
recent `MPTINVAL` that subsumes that address.

Another consequence of this specification is that it is generally unsafe to
update the MPT using a set of stores of a width less than the width of the MPT
entry, as it is legal for the implementation to read the MPT entries at any
time, including when only some of the partial stores have taken effect.

The IOMMU itself is a DMA capable device. The DMA performed by the IOMMU is
performed using the device ID of the IOMMU. A rule must be defined to associate
the IOMMU device ID itself with an `IOSDID` and MPT unless the IOMMU device ID
is encompassed by another rule that associates device IDs with an SD.
====

[[OP-2]]
=== Operand 2 register (`operand-2`)

The `operand-2` register holds the input operands or the output results of
operations requested through `control.OP`.

[caption="Register {counter:rimage}: ", reftext="Register {rimage}"]
[title="Operand-2 register (`operand-2`)"]
[wavedrom, , ]
....
{reg: [
  {bits: 12, name: 'S-RCID (WARL)'},
  {bits:  4, name: 'WPRI'},
  {bits: 12, name: 'S-MCID (WARL)'},
  {bits:  4, name: 'WPRI'},
  {bits:  4, name: 'SRL    (WARL)'},
  {bits:  4, name: 'SML    (WARL)'},
  {bits:  4, name: 'SQRID  (WARL)'},
  {bits:  1, name: 'SSRM   (WARL)'},
  {bits:  1, name: 'SSMM   (WARL)'},
  {bits:  2, name: 'WPRI'},
  {bits: 16, name: 'WPRI'}
], config:{lanes: 8, hspace:1024}}
....

The `SRL`, `SML`, `SSRM`, `SSMM`, `S-RCID`, and `S-MCID` fields are used to
determine the effective `RCID` and `MCID` for device-originated and
IOMMU-originated requests, using the RCID-value and MCID-value provided by the
IOMMU. These fields are inputs to the `SET_ENTRY` operation and outputs of the
`GET_ENTRY` operation. They are ignored by all other operations.

These fields are implemented only if `capabilities.QOSID` is set to 1.

When multiple rules map to the same `IOSDID`, the values of these fields must be
configured by software identically across all such rules.

The determination of the effective `RCID` and `MCID` is as follows:

[listing]
----
SRL_MASK = (1 << SRL) - 1
if SSRM == 0
    effective-RCID = (S-RCID & ~SRL_MASK) | (RCID-value & SRL_MASK)
else
    if ((RCID-value & ~SRL_MASK) | SRL_MASK) != ((1 << RCIDLEN) - 1)
        effective-RCID = RCID-value
    else
        effective-RCID = <unspecified but legal value>
    endif
endif

SML_MASK = (1 << SML) - 1
if SSMM == 0
    effective-MCID = (S-MCID & ~SML_MASK) | (MCID-value & SML_MASK)
else
    if ((MCID-value & ~SML_MASK) | SML_MASK) != ((1 << MCIDLEN) - 1)
        effective-MCID = MCID-value
    else
        effective-MCID = <unspecified but legal value>
    endif
endif
----

The `SQRID` identifies the QRI for requests originating from the devices and
the IOMMU associated with the SD, and accompanies the effective `RCID` and
`MCID` in the requests made by the device or IOMMU to the QRI.

[NOTE]
====
An implementation is allowed to internally organize the data such that the rules
classify a source ID to an `IOSDID`, and the `IOSDID` is used as an index into a
table that holds values for effective QoS ID determination and MPT checks.

If an identical `IOSDID` is configured in two rules but the QoS ID related
fields referenced by the rules are not identical, then it is unpredictable
whether the QoS ID related values from the first rule or the second rule will
be used.

Similarly, if an identical `IOSDID` is configured in two rules but the
MPT referenced by the rules is not identical, then it is unpredictable whether
the MPT from the first rule or the second rule will be used.

These are the only expected behaviors.
====
