[[chapter6]]
[[IO-MPT]]
== I/O MPT extension

Supervisor domains may be granted control over DMA-capable devices. When such
direct device association is supported, the system might also incorporate
multiple instances of IOMMU. Each IOMMU instance can be tied directly to a
supervisor domain, allowing that domain to manage address translation
and protection for DMA that originates from devices under its control.

To uphold isolation properties, the DMA from the devices and the IOMMU
linked with a supervisor domain must adhere strictly to the access protections
encoded in the MPT of the respective supervisor domain. Additionally, using the
MPT, the RDSM enforces that the IOMMU memory-mapped programming regions are
access-restricted to the supervisor domain the IOMMU is assigned to.

At any given time, a solitary supervisor domain is scheduled for execution on a
RISC-V hart by the root domain security manager (RDSM). As part of this
scheduling, the RDSM programs a pointer to the MPT into a CSR within the hart.
Unlike the RISC-V harts, DMA-capable devices connected to a supervisor domain
remain continuously active. Such devices might initiate DMA even if the
associated domain is not currently active on any RISC-V harts. As a result, the
MPT of all supervisor domains must be constantly active for DMA protection.
Furthermore, the IO subsystem must possess the capability to select the
appropriate MPT for enforcement based on the identity of the device initiating
the DMA.

Given this setup, the I/O subsystem is required to offer the following
functions:

* Supervisor Domain Classifier (SDCL): This classifier within the I/O subsystem
  interprets the attributes of a DMA request and determines the appropriate MPT
  for that request.

* MPT Checker (MPTCHK): This function ensures that stipulated access controls by
  `Smmpt` are applied to the memory regions accessed by the DMA. It uses the MPT
  identified by the SDCL.

Collectively, these two functionalities form a logical block in the I/O
subsystem, referred to as the I/O MPT checker.

=== Placement of I/O MPT checker

The IO Bridge serves as an intermediary, situated between the IO devices and the
system interconnect, with the primary role of processing DMA transactions. These
IO devices can initiate DMA transactions utilizing IO Virtual Addresses (IOVA).
Notably, an IOVA could be in the form of a Virtual Address (VA), Guest Virtual
Address (GVA), or Guest Physical Address (GPA). The configuration and
interfacing of the I/O MPT Checker with respect to the IO Bridge is graphically
represented in <<io-mpt-checker>>.

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title= "I/O MPT checker placement", id=io-mpt-checker]
image::images/IOMTTCHK.png[width=800]
[[fig:IOMPTCHK]]

The IO Bridge invokes the SDCL function using the SDID request interface (SDR)
and provides it the identifiers associated with the incoming transaction. The
SDCL classifies the request using the identifiers and provides the SDID and
the IOMMU ID on the SDID completion interface (SDC).

The IO Bridge uses the IOMMU ID to determine the IOMMU governing this request.
The IO Bridge uses the device translation request (DTR) interface to the
selected IOMMU to request address translation. The selected IOMMU provides the
response to the address translation request on the device translation completion
(DTC) interface. As part of the address translation process, the IOMMU may need
to access its in-memory data structures over its data structure interface (DSI).

The IO Bridge invokes the MPTCHK function over the MPT check request (MCR)
interface and provides it the SDID and physical address of the access. The
MPTCHK uses the SDID to determine the MPT associated with the supervisor
domain and checks if the physical address may be accessed by the device or IOMMU
associated with that supervisor domain. The result of the check is provided on
the MPT check completion (MCC) interface to the IO Bridge. As part of the MPT
check, the MPTCHK may need to perform implicit accesses to the MPT using the MPT
walk interface (MWI). To perform the checks the MPTCHK uses the same MPT table
format as used by the CPU's MMU. Using the same MPT table formats as the CPU's
MMU allows the same table to be used simultaneously by the CPU MMU and MPTCHK.
The MPT access permission lookup process used by MPTCHK is identical to that
specified by `Smmpt` extension in section "MPT access permissions lookup process".

The RISC-V memory model requires memory access from a hart to be single-copy
atomic. When RV32 is implemented the size of a single-copy atomic memory access
is up to 32-bits. When RV64 is implemented the size of a single-copy atomic
memory access is up to 64-bits. The size of a single-copy atomic memory access
implemented by MPTCHK is UNSPECIFIED but is required to be at least 32-bits if
all of the harts in the system implement RV32 and is required to be at least
64-bits if any of the harts in the system implement RV64. Software must follow
the rules outlined below to update MPT entries.

* It is generally unsafe to update fields of an MPT entry using stores of width
  less than the minimal single-copy atomic memory access supported by MPTCHK as
  it is legal for MPTCHK to read the entry at any time, including when only
  some of the partial stores have taken effect. For an update to be atomic,
  software must use a single store of width equal to the minimal single-copy
  atomic memory access supported by MPTCHK.

* MPTCHK is not required to immediately observe the software updates to an MPT
  entry. Software must use the `MPTINVAL` operation outlined in <<CTRL>> to
  invalidate any previous copies of that entry that may be in the MPTCHK caches
  to synchronize the updates to the entry with the operation of MPTCHK.

[NOTE]
====
If an MPT entry is changed, MPTCHK may use the old value of the entry or the
new value of the entry and the choice is unpredictable until software uses the
`MPTINVAL` operation to synchronize updates to the entry with the operation of
the MPTCHK. These are the only behaviors expected.
====

The I/O MPT checker provides a memory-mapped register programming interface.

As part of its operations, MPTCHK may need to read data from the MPT. The
provider (a memory controller or a cache) of the data may detect that the data
requested has an uncorrectable error and signal that the data is corrupted and
defer the error to MPTCHK. Such technique to defer the handling of the corrupted
data to the consumer of the data is also commonly known as data poisoning. The
effects of such errors may be contained to the transaction that caused the
corrupted data to be accessed. In the cases where the error affects the
transaction being processed but otherwise allows the MPTCHK to continue providing
service, MPTCHK may request the IO bridge to abort the transaction. The MPTCHK
may support the RISC-V RAS error record register interface (RERI) that specifies
methods for enabling error detection, logging the detected errors, and
configuring means to report the error to an error handler. When such a RAS
architecture is supported, errors such as attempted consumption of poisoned data
may be reported using the methods provided by the RAS architecture.

A supervisor domain, identified by an SDID, may be associated with one or more
IOMMU instances that are each identified by an IOMMU ID. A given IOMMU ID
however can only be associated with one supervisor domain.

[NOTE]
====
Usually an IOMMU is associated with a root port, and a root port connects to one
or more devices that are governed by that IOMMU. An I/O MPT checker may be
associated with more than one root port. A supervisor domain may be associated
with one or more devices from each of these root ports, necessitating the
association of an IOMMU instance for each root port to be used by that supervisor
domain. When a common I/O MPT checker is used to check I/O originating from
multiple root ports, the SDCL may be configured with rules to classify a device
connected to a root port as associated with a supervisor domain and with the
IOMMU instance that governs that device.
====

To support I/O MPT checks, the RDSM provides two types of configurations to the
I/O MPT checker:

* SDCL rules that classify one or more devices to an SDID and an IOMMU ID.

* Configurations that determine the MPT used to check memory requests
  originated by the IOMMUs and devices associated with that SDID, and
  configurations that determine the QoS IDs carried with such memory requests.

These configurations are programmed through the I/O MPT checker register
interface.

[[IOMPTABORT]]
=== Handling I/O MPT checker violations

A transaction is aborted if::

* The SDCL is not configured with a rule to classify the transaction.
* The memory targeted by the transaction is disallowed by the MPT.
* An access to the MPT by MPTCHK is disallowed by a physical memory attributes
  check or a physical memory protection check performed by the IO bridge.
* An access to the MPT by MPTCHK returns corrupted (poisoned) data.

If the aborted transaction is an IOMMU-initiated memory access then the IO
bridge signals such access faults to the IOMMU itself. The details of such
signaling is implementation defined.

If the aborted transaction is a write then the IO bridge may discard the write;
the details of how the write is discarded are implementation defined. If the IO
protocol requires a response for write transactions (e.g., AXI) then a response
as defined by the IO protocol may be generated by the IO bridge (e.g., SLVERR on
BRESP - Write Response channel). For PCIe, for example, write transactions are
posted and no response is returned when a write transaction is discarded.

If the aborted transaction is a read then the device expects a completion. The
IO bridge may provide a completion to the device. The data, if returned, in such
completion is implementation defined; usually it is a fixed value such as all 0
or all 1. A status code may be returned to the device in the completion to
indicate this condition. For AXI, for example, the completion status is provided
by SLVERR on RRESP (Read Data channel). For PCIe, for example, the completion
status field may be set to "Unsupported Request" (UR) or "Completer Abort" (CA).

Transactions permitted by the I/O MPT checker may still be disallowed by
additional checks outside the I/O MPT. The nature of such checks and the
handling of their violations are outside the scope of this specification.

=== I/O MPT Checker Register Interface

Each I/O MPT checker (IOMPTCHK) register interface is memory-mapped starting at
an 8-byte aligned physical address and includes the registers used to configure
the SDCL and MPTCHK functions in the I/O MPT checker.

[NOTE]
====
Implementations may choose to implement a coarser alignment for the start
address of the register interface. For example, some implementations may locate
the register interface within a naturally aligned 4-KiB region (a page) of
physical address space for each register interface. Coarser alignments may
enable register decoding to be implemented without a hardware adder circuit.
====

The behavior for register accesses where the address is not aligned to
the size of the access, or if the access spans multiple registers, or if the
size of the access is not 4 bytes or 8 bytes, is `UNSPECIFIED`. An aligned 4
byte access to a IOMPTCHK register must be single-copy atomic. Whether an 8 byte
access to an IOMPTCHK register is single-copy atomic is `UNSPECIFIED`, and such
an access may appear, internally to the IOMPTCHK implementation, as if two
separate 4 byte accesses were performed.

[NOTE]
====
The IOMPTCHK registers are defined in such a way that software can perform two
individual 4 byte accesses, or hardware can perform two independent 4 byte
transactions resulting from an 8 byte access, to the high and low halves of the
register as long as the register semantics, with regards to side-effects, are
respected between the two software accesses, or two hardware transactions,
respectively.
====

The IOMPTCHK registers have little-endian byte order (even for systems where
all harts are big-endian-only).

[NOTE]
====
Big-endian-configured harts that make use of I/O MPT may implement the `REV8`
byte-reversal instruction defined by the Zbb extension. If `REV8` is not
implemented, then endianness conversion may be implemented using a sequence
of instructions.
====

.I/O MPT Checker register layout
[width=100%]
[%header, cols="^3,10,^3, 18, 5"]
|===
|Offset|Name           |Size    |Description                 | Optional?
|0     |`capabilities` |4       |<<CAP, Capabilities     >>  | No
|4     |`status`       |4       |<<STS, Status           >>  | No
|8     |`control`      |4       |<<CTL, Control          >>  | No
|12    |`command`      |4       |<<CMD, Command          >>  | No
|16    |`data1`        |8       |<< Input/Output data 1  >>  | No
|24    |`data2`        |8       |<< Input/Output data 2  >>  | No
|===

The reset value is 0 for the following registers fields.

* `status` - `BUSY` and `CODE` fields
* `control` - `BUSY` field

The reset value for `control.MODE` is recommended to be `Off`.

After a reset the MPT PTE caches in the I/O MPT checker must have no
valid entries.

The reset value is `UNSPECIFIED` for all other registers and/or fields.

[[CAP]]
=== Capabilities (`capabilities`)

The `capabilities` register is a read-only register that holds the I/O MPT
checker capabilities.

[caption="Register {counter:rimage}: ", reftext="Register {rimage}"]
[title="Capabilities register fields"]
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'VER'},
  {bits:  1, name: 'QOSID'},
  {bits: 19, name: 'WPRI'},
  {bits:  4, name: 'custom'}
], config:{lanes: 4, hspace:1024}}
....

The `VER` field holds the version of the specification implemented by the
I/O MPT checker. The low nibble is used to hold the minor version of the
specification and the upper nibble is used to hold the major version of the
specification. For example, an implementation that supports version 1.0 of the
specification reports 0x10.

The `QOSID` field indicates whether associating QoS IDs with requests is
supported.

[[STS]]
=== Status register (`status`)

The `status` register provides the status of the operation requested using the
`command` register.

.Status Register (`status`)
[wavedrom, , ]
....
{reg: [
  {bits:  7, name: 'CODE (RO)'},
  {bits: 23, name: 'WPRI'},
  {bits:  1, name: 'BUSY (RO)'}
], config:{lanes: 2, hspace:1024}}
....

When the `command` register is written, IOMPTCHK may perform actions that do not
complete synchronously with the write. A write to the `command` register sets
the `status.BUSY` bit to 1, indicating that IOMPTCHK is executing the requested
operation. The behavior of writing the `command` or the `data*` registers
while the `status.BUSY` bit is 1 is `UNSPECIFIED`. Some implementations may
ignore the second write, while others may perform the operation specified by
that write. Software must verify that `BUSY` is 0 before writing to the
`command` or `data*` registers.

[NOTE]
====
An implementation that always completes the requested operation synchronously
with a write to the `command` register may hardwire the `BUSY` bit to 0.
====

When the `status.BUSY` bit reads 0, the operation is complete, and the
`status.CODE` field provides a status value (<<IOMPTCHK_STS>>) for the
requested operation.

[[IOMPTCHK_STS]]
.`status.CODE` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`STATUS` | Description
| 0       | Reserved.
| 1       | Operation completed successfully.
| 2       | Invalid operation (`OP`) requested.
| 3       | Operation requested for invalid `RULEID`.
| 4       | Operation requested for invalid `SDID`.
| 5       | Illegal or invalid operand encodings.
| 6-127   | Reserved for future standard use.
| 128-255 | Designated for custom use.
|===


[[CTRL]]
=== Control (`control`)

This register is used to control the operations of the I/O MPT checker.
An implementation may allow one or more fields in the register to be
writable to support enabling or disabling the feature controlled by that
field. All I/O MPT checkers must support the `Off` and `On` values for
the `MODE` field.

.Control Register (`control`)
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'MODE (WARL)'},
  {bits:  1, name: 'MBE (WARL)'},
  {bits:  1, name: 'MXL (WARL)'},
  {bits: 26, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

The I/O MPT checker may be configured to be in the following modes:

[[IOMPTCHK_MODE]]
.I/O MPT checker modes (`MODE`)
[width=100%]
[%header, cols="16,^12,70"]
|===
| Name         | Encoding ^| Description
| Off          | 0         | No inbound memory transactions are allowed.
| On           | 1         | I/O MPT checker is operational.
| Reserved     | 2-13      | Reserved for future standard use.
| Custom       | 14-15     | Designated for custom use.
|===

When the `MODE` field value is changed to `Off` the I/O MPT checker guarantees
that in-flight transactions, observed at the time of the write to this field,
from devices connected to the I/O MPT checker will either be processed with the
configurations applicable to the old value of the `MODE` field or are aborted
<<IOMPTABORT>>. It also ensures that all transactions and previous requests from
devices that have already been processed by the I/O MPT checker are committed to
a global ordering point such that they can be observed by all RISC-V harts,
devices, I/O MPT checkers, and IOMMUs in the platform.

When an I/O MPT checker is transitioned to `Off` state, the I/O MPT checker
may retain information configured into the SDCL and/or MPTCHK. The MPTCHK may
retain information cached from the MPTs. Software must use suitable invalidation
commands to invalidate the cached entries. Software must initialize all SDCL
rules and SDID configurations prior to transitioning the I/O MPT checker to `On`
state.

When the `MODE` is not `Off`, software changes to fields besides `MODE` may
cause UNSPECIFIED behavior. When the state is `On`, software must first change
the `MODE` to `Off` without changing the values of any other field.

A write to `control` register may require the I/O MPT checker to perform many
operations that may not occur synchronously to the write. When a write is
observed by `control`, the `BUSY` bit is set to 1. When the `BUSY` bit is 1,
behavior of additional writes to `control` are UNSPECIFIED. Some implementations
may ignore the second write and others may perform the actions determined by the
second write. Software must verify that the `BUSY` bit is 0 before writing to
the `control` register. If the `BUSY` bit reads 0 then the I/O MPT checker has
completed the operations associated with the previous write to the `control`
register. An I/O MPT checker that can complete these operations synchronously
may hard-wire this bit to 0

The `MBE` field determines the endianness of the access made by I/O MPT checker
to memory resident data structures such as the MPTs. When this field is 0, the
accesses are performed as little-endian acesses and when 1 as big-endian
accesses.

The `MXL` field controls the MPT modes that may be used for memory protection
checks as defined in <<MPT_MODE_ENC-0>> and <<MPT_MODE_ENC-1>>. Attempts to
configure an unsupported MPT mode must be rejected with `status.CODE` set to
"Illegal or invalid operand encodings (CODE=5)".

[[MPT_MODE_ENC-0]]
.Encodings of MPT modes when `control.MXL=0`
[%autowidth,float="center",align="center"]
[%header, cols="^3,^3,20"]
|===
3+^|               `control.MXL=0`
^|Value ^| Name     ^| Description
|0       |`Bare`     | No page-based memory protection.
|1       |`Smmpt43`  | Page-based memory protection for up to 43-bit
                       physical address spaces.
|2       |`Smmpt52`  | Page-based memory protection for up to 52-bit
                       physical address spaces.
|3       |`Smmpt64`  | Page-based memory protection for up to 64-bit
                       physical address spaces.
|4-13    |-          |`_Reserved for future standard use._`
|14-15   |-          |`_Designated for custom use._`
|===

[[MPT_MODE_ENC-1]]
.Encodings of MPT modes when `control.MXL=1`
[%autowidth,float="center",align="center"]
[%header, cols="^3,^3,20"]
|===
^|Value ^| Name    ^| Description
|0       |`Bare`    | No page-based memory protection.
|1       |`Smmpt34` | Page-based memory protection for up to 34-bit
                      physical address spaces.
|2       |-         |`_Reserved for future standard use._`
|3       |-         |`_Designated for custom use._`
|===

The `MBE` and/or `MXL` fields may be hard-wired if only a single value is
supported for these fields by an implementation.

[[CMD]]
=== Command register (`command`)

The `command` register is used to initiate I/O MPT checker operations. The
specific operation is identified by the `OP` field within the `command`
register. Operands required to complete the operation are supplied either in
dedicated fields of the `command` register or in one or more of the associated
`data*` registers.  The `OP` field also defines the encoding of the
`operand` fields in the `command` register and of the `data*` registers for
that operation.

.Command Register (`command`)
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits: 24, name: 'operands (WARL)'},
], config:{lanes: 2, hspace:1024}}
....

[[IOMPTCHK_OP]]
.I/O MPT checker operations (`OP`)
[width=100%]
[%header, cols="16,^12,70"]
|===
| Operation         | Encoding ^| Description
| --                | 0         | Reserved for future standard use.
| `IOFENCE`         | 1         | Ensure that all previous read and write
                                  requests from devices already processed by
                                  IOMPTCHK are committed to a global ordering
                                  point such that they can be observed by all
                                  RISC-V harts, IOMMUs, and devices in the
                                  system.
| `SET_SDCL_ENTRY`  | 2         | Configure a rule in the SDCL.
| `GET_SDCL_ENTRY`  | 3         | Read the configuration of an SDCL rule.
| `SET_SDCFG_ENTRY` | 4         | Configure MPT and QoS ID parameters for an SD.
| `GET_SDCFG_ENTRY` | 5         | Read the configuration associated with an SD.
| `MPTINVAL`        | 6         | Ensure that stores to an MPT are observed by
                                  MPTCHK before subsequent implicit reads by
                                  MPTCHK to the corresponding MPT.
| --                | 7–127     | Reserved for future standard use.
| --                | 128–255   | Designated for custom use.
|===

Before requesting an operation using the `command` register, software must
program the fields of the `data1` and `data2` registers as required by that
operation. Fields not used by an operation are ignored.

=== Configure a rule in the SDCL - `SET_SDCL_ENTRY`

The `SET_SDCL_ENTRY` operation configures an SDCL rule to classify DMA requests
based on the identifiers associated with the requests, in order to determine the
supervisor domain ID (`SDID`) and the IOMMU ID (`IOMMU_ID`).

This operation uses the operands in the `command` register and the `data1`
register. The contents of the `data2` register are ignored by this operation.

For this operation, the fields of the `command` and `data1` registers are
interpreted as follows.

.`command` register layout for `SET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  8, name: 'RULEID (WARL)'},
  {bits: 16, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

.`data1` register layout for `SET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'SRC_IDT (WARL)'},
  {bits:  2, name: 'SRC_IDM (WARL)'},
  {bits:  2, name: 'TEE_FLT (WARL)'},
  {bits: 24, name: 'SRC_ID'},
  {bits:  8, name: 'IOMMU_ID (WARL)'},
  {bits:  6, name: 'SDID (WARL)'},
  {bits: 18, name: 'WPRI'}
], config:{lanes: 8, hspace:1024}}
....

The `SRC_IDT` field identifies the type of identifier from the DMA transaction
used by this classification rule. The `SRC_IDT` encodings are listed in
<<SRC_IDT>>.

[[SRC_IDT]]
.`data1.SRC_IDT` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`SRC_IDT` | Description
|    0     | None. This rule does not match any incoming transaction. All other
             fields of the `data1` register are ignored.
|    1     | Filter by device ID. The device ID is specified in `SRC_ID` field.
|    2     | Filter by PCIe IDE stream ID and PCIe segment ID. The IDE stream ID
             is specified in the bits 7:0 of the `SRC_ID` field and the segment
             ID in bits 15:8 of the `SRC_ID`. The bits 23:16 of the `SRC_ID`
             field are ignored.
|  3 - 7   | Reserved for future standard use.
|  8 - 15  | Designated for custom use.
|===

[NOTE]
====
In PCIe systems, an originating device can be pinpointed using a unique 16-bit
identifier. This identifier is a composite of the PCI bus number (8 bits),
device number (5 bits), and function number (3 bits), collectively referred to
as the routing identifier or RID. In scenarios where an IOMMU manages multiple
hierarchies, there's also an optional segment number, which can be up to 8 bits.
Each hierarchy in this context represents a distinct PCI Express I/O
interconnect topology. Here, the Configuration Space addresses, which are
delineated by the Bus, Device, and Function number tuple, remain distinct.
Sometimes, the term Hierarchy is synonymous with Segment. Especially when in
Flit Mode, the Segment number can be part of a Function's ID.
====

The `SRC_IDM` field can configure `SRC_ID` matching mode for transactions. The
`SRC_IDM` encodings are listed in <<SRC_IDM>>.

[[SRC_IDM]]
.data1.SRC_IDM field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`SRC_IDM` | Description
|    0     | Reserved for future standard use.
|    1     | TOR. If TOR (Top-Of-Range) is selected, the `SRC_ID` field
             forms the top of a range of source IDs. If rule __r__'s `SRC_IDM`
             is set to TOR, the rule matches any source ID __s__ if: __s__ is
             greater than or equal to `SRC_ID` of rule __r-1__ and is less than
             the `SRC_ID` of rule __r__. If __r__ is 0, then zero is used as the
             lower bound. If `SRC_ID` of rule __r-1__ is greater than or equal
             to that of rule __r__ and TOR is selected for rule __r__, then rule
             __r__ does not match any address.
|    2     | Unary. If Unary is selected, then this rule matches if all the bits
             of the source ID of the transaction match the value configured in
             the `SRC_ID` field.
|    3     | NAPOT. If NAPOT is selected, then the rule matches a naturally
             aligned power-of-two range of source IDs. In this mode, the lower
             bits of the `SRC_ID`, up to and including the first low-order zero
             bit, are masked; the unmasked bits are compared with the
             corresponding bits in the source ID of the transaction to match.
|===

[NOTE]
====
The following example illustrates the use of `SRC_IDM=NAPOT` when `SRC_IDT` is
by `DEVID` and a 24-bit PCIe `device_id` comprised of the segment, bus, device,
and function number is used. In the table below, `y` acts as a placeholder
representing any 1-bit value.

.`SRC_IDM` with `SRC_IDT` set to Filter by device ID
[cols="^1,3,3", options="header"]
|===
| `SRC_IDM` | `SRC_ID`                     | *Comment*
| 1         |`yyyyyyyy  yyyyyyyy  yyyyyyyy`| One specific seg:bus:dev:func
| 2         |`yyyyyyyy  yyyyyyyy  yyyyy011`| seg:bus:dev - any func
| 2         |`yyyyyyyy  yyyyyyyy  01111111`| seg:bus - any dev:func
| 2         |`yyyyyyyy  01111111  11111111`| seg - any bus:dev:func
|===

====

The `TEE_FLT` field may be used to filter transactions associated with a Trusted
Execution Environment (TEE). The encodings for the `TEE_FLT` field can be found
in <<TEE_FLT>>.

[[TEE_FLT]]
.`data1.TEE_FLT` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`TEE_FLT` | Description
|   0      | Reserved for future standard use.
|   1      | Rule matches TEE-associated transactions.
|   2      | Rule matches transactions that are not TEE associated.
|   3      | Rule matches both TEE-associated and non-TEE associated
             transactions.
|===

[NOTE]
====
PCIe IDE provides security for transactions from one Port to another. These
transactions might be initiated by contexts within the device, such as an SR-IOV
virtual function, which are associated with a Trusted Execution Environment
(TEE). Within the IDE TLP header, there's a "T" bit that helps differentiate
transactions related to a TEE. The `TEE_FLT` filter can be employed to associate
these TEE-related transactions with a different supervisor domain than the
transactions not related to TEE. This distinction is made even if both types of
transactions are received on the same PCIe IDE stream.

Fields such as `TEE_FLT` and `IOMMU_ID` are WARL and may be hardwired to 0 if
the implementation does not support PCIe IDE and/or an IOMMU.
====

The `IOMMU_ID` field identifies the instance of the IOMMU that should be used to
provide address translation and protection for the transactions matching this
rule.

The `SDID` field identifies the supervisor domain whose memory is accessed by
this transaction.

=== Read the configuration of an SDCL rule - `GET_SDCL_ENTRY`

The `GET_SDCL_ENTRY` operation reads the configuration of an SDCL rule
identified by `RULEID`. This operation ignores the contents of the `data*`
registers. Upon success, the configuration of the rule identified by
`command.RULEID` is returned in the `data1` register.

The contents of the `data1` register are `UNSPECIFIED` if the operation fails
or if it is invoked without a preceding `SET_SDCL_ENTRY` for the specified
`RULEID`. The contents of the `data1` register are `UNSPECIFIED`, regardless
of whether the operation completes successfully.

The interpretation of the `command` and `data1` registers for this operation is
identical to that of the `SET_SDCL_ENTRY` operation.

=== Set Supervisor Domain Configurations - `SET_SDCFG_ENTRY`

The `SET_SDCFG_ENTRY` operation configures MPT and QoS ID parameters for a
supervisor domain in MPTCHK. This operation uses the operands in the `command`,
`data1`, and `data2` registers. The fields of these registers are interpreted
as follows.

.`command` register layout for `SET_SDCFG_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  6, name: 'SDID (WARL)'},
  {bits: 18, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

.`data1` register layout for `SET_SDCFG_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'MPT_MODE (WARL)'},
  {bits:  6, name: 'WPRI'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'WPRI'}
], config:{lanes: 4, hspace:1024}}
....

.`data2` register layout for `SET_SDCFG_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits: 12, name: 'S-RCID (WARL)'},
  {bits:  4, name: 'WPRI'},
  {bits: 12, name: 'S-MCID (WARL)'},
  {bits:  4, name: 'WPRI'},
  {bits:  4, name: 'SRL    (WARL)'},
  {bits:  4, name: 'SML    (WARL)'},
  {bits:  4, name: 'SQRID  (WARL)'},
  {bits:  1, name: 'SSRM   (WARL)'},
  {bits:  1, name: 'SSMM   (WARL)'},
  {bits:  2, name: 'WPRI'},
  {bits: 16, name: 'WPRI'}
], config:{lanes: 8, hspace:1024}}
....

The `MPT_MODE` field identifies the mode of the MPT. It's interpreted as
outlined in <<mpt-32>> when `capabilities.MPTM` is 1, and as detailed in
<<mpt-64>> otherwise. The `PPN` field programs the PPN of the root page of the
MPT. When `MPT_MODE` is `Bare`, the `PPN` field must be set to zero.

The `SRL`, `SML`, `SSRM`, `SSMM`, `S-RCID`, and `S-MCID` fields are used to
determine the effective `RCID` and `MCID` for device-originated and
IOMMU-originated requests, using the RCID-value and MCID-value provided by the
IOMMU. These fields are implemented only if `capabilities.QOSID` is set to 1.

The determination of the effective `RCID` and `MCID` is as follows:

[listing]
----
SRL_MASK = (1 << SRL) - 1
if SSRM == 0
    effective-RCID = (S-RCID & ~SRL_MASK) | (RCID-value & SRL_MASK)
else
    if ((RCID-value & ~SRL_MASK) | SRL_MASK) != ((1 << RCIDLEN) - 1)
        effective-RCID = RCID-value
    else
        effective-RCID = <unspecified but legal value>
    endif
endif

SML_MASK = (1 << SML) - 1
if SSMM == 0
    effective-MCID = (S-MCID & ~SML_MASK) | (MCID-value & SML_MASK)
else
    if ((MCID-value & ~SML_MASK) | SML_MASK) != ((1 << MCIDLEN) - 1)
        effective-MCID = MCID-value
    else
        effective-MCID = <unspecified but legal value>
    endif
endif
----

The `SQRID` identifies the QRI for requests originating from the devices and
the IOMMU associated with the SD, and accompanies the effective `RCID` and
`MCID` in the requests made by the device or IOMMU to the QRI.

=== Get Supervisor Domain Configurations - `GET_SDCFG_ENTRY`

The `GET_SDCFG_ENTRY` operation reads the configuration of the supervisor domain
identified by `SDID` from MPTCHK. This operation ignores the contents of the
`data*` registers. Upon success, the configuration of the supervisor domain
identified by `command.SDID` is returned in the `data1` register.

The contents of the `data1` and `data2` registers are `UNSPECIFIED` if the
operation fails or if it is invoked without a preceding `SET_SDCFG_ENTRY` for
the specified `SDID`.

The interpretation of the `command`, `data1`, and `data2` registers for this
operation is identical to that of the `SET_SDCFG_ENTRY` operation.

=== MPT Permission Cache Invalidation - `MPTINVAL`

This operation ensures that stores to an MPT are observed by MPTCHK before
subsequent implicit reads by MPTCHK to the corresponding MPT.

This operation uses the operands in the `command` register and the `data1`
register. The contents of the `data2` register are ignored by this operation.

For this operation, the fields of the `command` and `data1` registers are
interpreted as follows.

.`command` register layout for `MPTINVAL` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  6, name: 'SDID (WARL)'},
  {bits:  2, name: 'WPRI'},
  {bits:  1, name: 'SDID_V'},
  {bits: 15, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

.`data1` register layout for `MPTINVAL` operation
[wavedrom, , ]
....
{reg: [
  {bits:  1, name: 'PPN_V'},
  {bits:  1, name: 'S'},
  {bits:  8, name: 'WPRI'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'WPRI'}
], config:{lanes: 4, hspace:1024}}
....

The `PPN_V` field indicates if the `PPN` field is valid and the `SDID_V` field
indicates if the `SDID` field is valid for the operation. When a field is not
valid for an operation, it is ignored by the operation. When the `PPN_V` field
is 1, the `S` field sets the address range size for the `MPTINVAL` operation.
With an `S` field value of 0, the range size is 4 KiB. But, when the `S` field
has a value of 1, the `MPTINVAL` operation focuses on a NAPOT range. This range
is decided by the low-order bits of the `PPN` field, going up to the first
low-order 0 bit (inclusive of this position). If the initial low-order 0 bit
position is denoted as `x`, the size of the range is computed as
`(1 << (12 + x + 1))`.

When `PPN_V` is set to 1, if the address range specified by `PPN` and `S` is
invalid, the operation may or may not be performed. If the `PPN_V` and `S` are
both set to 1 and all bits of the `PPN` operand are 1, the behavior of
`MPTINVAL` operation is UNSPECIFIED.

. `MPTINVAL` operands and operations
[%autowidth,float="center",align="center"]
[%header, cols="^2,^2,20"]
|===
| `PPN_V` | `SDID_V` | Operation
|   0     |  0        | Invalidates information cached from any MPT for all
                        supervisor domain address spaces.
|   0     |  1        | Invalidates information cached from the MPT for the
                        address space of the supervisor domain identified by
                        the `SDID` operand.
|   1     |  0        | Invalidates information cached from the MPT for the
                        address range in the `PPN` operand for all supervisor
                        domain address spaces.
|   1     |  1        | Invalidates information cached from the MPT for the
                        address range in the `PPN` operand for the supervisor
                        domain address space identified by the `SDID` operand.
|===


[NOTE]
====
The following example illustrates the use of `S` field to specify an address
range for the `MPTINVAL` operation. The example shows encoding ranges of up to
8 GiB. Larger ranges may be encoded using the upper address bits (bits 43:22)
of the `PPN` field.

. Examples of specifying address range sizes using `S` field
[cols="3,1,3", options="header"]
|===
| `PPN[21:0]`              | `S` | *Address Range Size*
| `yyyyy yyyyyyyy yyyyyyyy`|  0  | 4  KiB
| `yyyyy yyyyyyyy yyyyyyy0`|  1  | 8  KiB
| `yyyyy yyyyyyy0 11111111`|  1  | 2  MiB
| `yyy01 11111111 11111111`|  1  | 1  GiB
| `01111 11111111 11111111`|  1  | 8  GiB
|===

====

[NOTE]
====
Simpler implementations may ignore the operands of `MPTINVAL` operation and
perform a global invalidation of all information cached from any MPT.

A consequence of this specification is that an implementation may use any
information for an address that was valid in the MPT at any time since the most
recent `MPTINVAL` that subsumes that address.

Another consequence of this specification is that it is generally unsafe to
update the MPT using a set of stores of a width less than the width of the MPT
entry, as it is legal for the implementation to read the MPT entries at any
time, including when only some of the partial stores have taken effect.

The IOMMU itself is a DMA capable device. The DMA performed by the IOMMU is
performed using the device ID of the IOMMU. A rule must be defined to associate
the IOMMU device ID itself with an `SDID` and MPT unless the IOMMU device ID
is encompassed by another rule that associates device IDs with an SD.

Even if the MPTCHK denies a reqyest, the MPTCHK is allowed to cache the
corresponding MPT entry.
====

=== I/O Fence Operation - `IOFENCE`

Ensure that all previous read and write requests from devices already processed
by IOMPTCHK are committed to a global ordering point such that they can be
observed by all RISC-V harts, IOMMUs, and devices in the system.

The contents of the `data1` and `data2` registers are ignored by this
operation. For this operation, the fields of the `command` register are
interpreted as follows.

.`command` register layout for `IOFENCE` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits: 24, name: 'WPRI'},
], config:{lanes: 2, hspace:1024}}
....

=== Treatment of Device-Side Address Translation Caches

Some devices may participate in the translation process and provide a
device-side ATC (DevATC) for their own memory accesses. By providing a
DevATC, the device shares the translation caching responsibility and thereby
reduces the probability of "thrashing" in the IOATC. The DevATC may be sized
by the device to suit its unique performance requirements and may also be
used to optimize DMA latency by prefetching translations. Such mechanisms
require close cooperation between the device and the IOMMU through a
protocol. For PCIe, for example, the Address Translation Services (ATS)
protocol may be used by the device to request translations to cache in the
DevATC and to synchronize it with updates made to software address
translation data structures. +

If the IOBRIDGE and the IOMMUs support the PCIe ATS specification cite:[PCI],
the IOMMU supports two forms of transactions:

* Translated Requests
* PCIe ATS Translation Requests

PCIe ATS Translation Requests are used by the device to obtain a translation
for an I/O virtual address (IOVA) specified in the request. These translated
addresses may be cached by the device in its DevATC and used as addresses for
subsequent Translated Requests.

For a PCIe ATS Translation Request, the IOMMU performs a two-stage address
translation to determine the permissions and the size of the translation to
be provided in the completion of the request. The IOMMU may be configured to
return either the SPA or a GPA (see `T2GPA` field in Device Context
cite:[IOMMU]) as the translation of an IOVA in the response.

Translated Requests also invoke the IOMMU to determine if the device is
authorized to use these transactions (see `EN_ATS` field in Device Context).
When the IOMMU is configured to return a GPA in response to a PCIe ATS
Translation Request, the IOMMU translates the GPA to an SPA when invoked to
process a Translated Request.

If the IOMMU provides an Unsupported Request (UR) or a Completer Abort (CA) as
a response to a PCIe ATS Translation Request, the IOBRIDGE forwards that
response to the device. If the IOMMU provides a Success response with both
R and W permissions set to 0, it indicates that the page requested by the
Translation Request is not available, and the IOBRIDGE forwards that response
to the device. In these cases, the MPTCHK is not invoked to check the responses.

For all other responses to a PCIe ATS Translation Request, further processing
by the IOBRIDGE depends on whether the IOMMU is configured to return an SPA
or a GPA in the response.

When the IOMMU is configured to return a GPA as the translated address in
response to a PCIe ATS Translation Request, the IOBRIDGE forwards such
responses directly to the device. The MPTCHK is not invoked in this case.

When the response to a PCIe ATS Translation Request is an SPA, the IOBRIDGE
invokes the MPTCHK on the entire range of translated addresses returned by the
IOMMU. If the IOMMU grants read permission to the device, the MPT must also
grant read permission; if the IOMMU grants write permission to the device, the
MPT must also grant write permission; and if the IOMMU grants permission to
execute, the MPT must also grant execute permission for the entire range of
translated addresses provided in the PCIe ATS Translation Completion. If the
MPTCHK determines that the address is not accessible or that the requested
permissions are not present, the IOBRIDGE provides an Unsupported Request (UR)
response to the device. If the MPTCHK succeeds, the translation completion is
returned to the device.

For a Translated Request, if the IOMMU provides a UR or CA response, the
request is aborted. Otherwise, the IOBRIDGE invokes the MPTCHK on the SPA
range provided by the IOMMU. If the MPTCHK fails, the request is aborted. If
the MPTCHK succeeds, the IOBRIDGE allows the request to access memory.

When protocols other than PCIe ATS are used to support a device-side ATC, the
IOBRIDGE shall apply similar rules to enforce memory protection as those
defined for PCIe ATS when implementing the MPTCHK functionality.
