[[IO-MPT]]

== I/O MPT Checker

Supervisor domains may be granted control over DMA-capable devices. When such
direct device association is supported, the system might also incorporate
multiple instances of IOMMU. Each IOMMU instance can be tied directly to a
supervisor domain, allowing that domain to manage address translation
and protection for DMA that originates from devices under its control.

To uphold isolation properties, the DMA from the devices and the IOMMU
linked with a supervisor domain must adhere strictly to the access protections
encoded in the MPT of the respective supervisor domain. Additionally, using the
MPT, the RDSM enforces that the IOMMU memory-mapped programming regions are
access-restricted to the supervisor domain the IOMMU is assigned to.

At any given time, a solitary supervisor domain is scheduled for execution on a
RISC-V hart by the root domain security manager (RDSM). As part of this
scheduling, the RDSM programs a pointer to the MPT into a CSR within the hart.
Unlike the RISC-V harts, DMA-capable devices connected to a supervisor domain
remain continuously active. Such devices might initiate DMA even if the
associated domain is not currently active on any RISC-V harts. As a result, the
MPT of all supervisor domains must be constantly active for DMA protection.
Furthermore, the input/output (I/O) subsystem must possess the capability to
select the appropriate MPT for enforcement based on the identity of the device
initiating the DMA.

Given this setup, the I/O subsystem is required to offer the following
functions:

* Supervisor Domain Classifier (SDCL): This function interprets the attributes
  of a DMA request and determines the appropriate MPT for that request.

* MPT Check: This function ensures that stipulated access controls by
  `Smmpt` are applied to the memory regions accessed by the DMA. It uses the MPT
  identified by the SDCL.

Collectively, these two functionalities form a logical block in the I/O
subsystem, referred to as the I/O MPT Checker.

=== Placement of I/O MPT Checker

The I/O Bridge serves as an intermediary, situated between the I/O devices and the
system interconnect, with the primary role of processing DMA transactions. These
I/O devices can initiate DMA transactions utilizing I/O Virtual Addresses (IOVA).
Notably, an IOVA could be in the form of a Virtual Address (VA), Guest Virtual
Address (GVA), or Guest Physical Address (GPA). The configuration and
interfacing of the I/O MPT Checker with respect to the I/O Bridge is graphically
represented in <<io-mpt-checker>>.

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title= "I/O MPT checker placement", id=io-mpt-checker]
image::images/IOMPTCHK.png[width=800]
[[fig:IOMPTCHK]]

The I/O Bridge invokes the I/O MPT Checker using the SDID request interface (SDR)
and provides it the identifiers associated with the incoming transaction. The
SDCL classifies the request using the identifiers and provides the SDID and
the IOMMU ID on the SDID completion interface (SDC).

The I/O Bridge uses the IOMMU ID to determine the IOMMU governing this request.
The I/O Bridge uses the device translation request (DTR) interface to the
selected IOMMU to request address translation. The selected IOMMU provides the
response to the address translation request on the device translation completion
(DTC) interface. As part of the address translation process, the IOMMU may need
to access its in-memory data structures over its data structure interface (DSI).

The I/O Bridge invokes the I/O MPT Checker over the MPT check request (MCR)
interface and provides it the SDID and machine physical address of the access.
The I/O MPT Checker uses the SDID to determine the MPT associated with the
supervisor domain and checks if the machine physical address may be accessed by
the device or IOMMU associated with that supervisor domain. The result of the
check is provided on the MPT check completion (MCC) interface to the I/O Bridge.
As part of the MPT check, the I/O MPT Checker may need to perform implicit
accesses to the MPT using the I/O MPT Checker data structure interface (MDSI).
To perform the checks the I/O MPT Checker uses the same MPT table format as
used by the CPU's MMU. Using the same MPT table formats as the CPU's MMU allows
the same table to be used simultaneously by the CPU MMU and I/O MPT Checker.
The MPT permission lookup process used by I/O MPT Checker is identical to that
specified by `Smmpt` extension in section "MPT access permissions lookup
process".

The RISC-V memory model requires memory access from a hart to be single-copy
atomic. When RV32 is implemented the size of a single-copy atomic memory access
is up to 32-bits. When RV64 is implemented the size of a single-copy atomic
memory access is up to 64-bits. The size of a single-copy atomic memory access
implemented by I/O MPT Checker is UNSPECIFIED but is required to be at least
32-bits if all of the harts in the system implement RV32 and is required to be
at least 64-bits if any of the harts in the system implement RV64.

The MPT entries have a `V` bit that when set to 1 indicates that the entry is
valid.

Software is allowed to make updates to a MPT entry that has the `V` bit set to
1. However, some rules as outlined must be followed.

* Software must use a single atomic store that updates all or parts of an MPT
  PTE for the update to be atomically observed by the I/O MPT Checker.

* If the update to a field of the MPT entry will make the field inconsistent
  with another field of the entry then software must first set the `V` bit to 0
  and use the `MPTINVAL` operation outlined in <<CTRL>> to invalidate previous
  copies of the entry that may be in the I/O MPT Checker caches to synchronize
  the updates to the entry with the operation of I/O MPT Checker.

* I/O MPT Checker is not required to immediately observe the software updates to
  an MPT entry. Software must use the `MPTINVAL` operation outlined in <<CTRL>>
  to invalidate any previous copies of that entry that may be in the I/O MPT
  Checker caches to synchronize the updates to the entry with the operation of
  I/O MPT Checker.

[NOTE]
====
If an MPT entry is changed, I/O MPT Checker may use the old value of the entry
or the new value of the entry and the choice is unpredictable until software
uses the `MPTINVAL` operation to synchronize updates to the entry with the
operation of the I/O MPT Checker. These are the only behaviors expected.
====

The RISC-V memory model specifies byte-invariance for the entire address space.
When mixed-endian mode of operation is supported, the I/O MPT Checker must
implement byte-invariant addressing such that a byte access to a given address
accesses the same memory location in both little-endian and big-endian mode of
operation.

The I/O MPT Checker is not allowed to cache an MPT entry whose `V` (valid) bit
is clear.

The I/O MPT Checker provides a memory-mapped register programming interface.

As part of its operations, I/O MPT Checker may need to read data from the MPT.
The provider (a memory controller or a cache) of the data may detect that the
data requested has an uncorrectable error and signal that the data is corrupted
and defer the error to I/O MPT Checker. Such technique to defer the handling of
the corrupted data to the consumer of the data is also commonly known as data
poisoning. The effects of such errors may be contained to the transaction that
caused the corrupted data to be accessed. In the cases where the error affects
the transaction being processed but otherwise allows the I/O MPT Checker to
continue providing service, the I/O MPT Checker may request the I/O Bridge to
abort the transaction.  The I/O MPT Checker may support the RISC-V RAS error
record register interface (RERI) that specifies methods for enabling error
detection, logging the detected errors, and configuring means to report the
error to an error handler. When such a RAS architecture is supported, errors
such as attempted consumption of poisoned data may be reported using the
methods provided by the RAS architecture.

A supervisor domain, identified by an SDID, may be associated with one or more
IOMMU instances that are each identified by an IOMMU ID. A given IOMMU ID
however can only be associated with one supervisor domain.

The IOMMU is itself a DMA-capable device, and performs DMA using its own
device ID. An explicit rule must associate the IOMMUâ€™s device ID with an
`SDID` and MPT, unless that device ID is already covered by another rule that
maps device IDs to a supervisor domain. The IOMMU ID configured in the rule
matching the IOMMU's device ID is ignored when the rule is looked up for memory
accesses originated by the IOMMU itself.

[NOTE]
====
Usually an IOMMU is associated with a root port, and a root port connects to one
or more devices that are governed by that IOMMU. An I/O MPT Checker may be
associated with more than one root port. A supervisor domain may be associated
with one or more devices from each of these root ports, necessitating the
association of an IOMMU instance for each root port to be used by that supervisor
domain. When a common I/O MPT Checker is used to check I/O originating from
multiple root ports, the I/O MPT Checker may be configured with rules to classify
a device connected to a root port as associated with a supervisor domain and with
the IOMMU instance that governs that device.
====

To support MPT checks, the RDSM provides two types of configurations to the
I/O MPT Checker:

* SDCL rules that classify one or more devices to an SDID and an IOMMU ID.

* Configurations that determine the MPT used to check memory requests
  originated by the IOMMUs and devices associated with that SDID, and
  configurations that determine the QoS IDs carried with such memory requests.

These configurations are programmed through the I/O MPT Checker register
interface.

While the common use case involves the use of an IOMMU, the architecture
supports implementations without an IOMMU. In such implementations, the SDCL
rules classify devices to an SDID alone and no IOMMU ID is associated with the
rules.

[[IOMPTABORT]]
=== Handling I/O MPT Checker violations

A transaction shall be aborted if:

* The I/O MPT Checker is in `Off` mode, or is in `Bare` mode and the transaction
  is TEE-associated.
* The I/O MPT Checker is in `On` mode but is not configured with a rule to
  classify the transaction.
* The memory targeted by the transaction is disallowed by the MPT.
* An access to the MPT by I/O MPT Checker is disallowed by a physical memory
  attributes check or a physical memory protection check performed by the IO
  Bridge.
* An access to the MPT by the I/O MPT Checker returns corrupted (poisoned) data.

If the aborted transaction is an IOMMU-initiated memory access then the IO
Bridge signals such access faults to the IOMMU itself. The details of such
signaling is implementation defined. Please see the IOMMU specification for
the handling of access faults on IOMMU initiated memory accesses.

If the aborted transaction is a write then the I/O Bridge may discard the write;
the details of how the write is discarded are implementation defined. If the IO
protocol requires a response for write transactions (e.g., AXI) then a response
as defined by the I/O protocol may be generated by the I/O Bridge (e.g., SLVERR on
BRESP - Write Response channel). For PCIe, for example, write transactions are
posted and no response is returned when a write transaction is discarded.

If the aborted transaction is a read then the device expects a completion. The
I/O Bridge may provide a completion to the device. The data, if returned, in such
completion is implementation defined; usually it is a fixed value such as all 0
or all 1. A status code may be returned to the device in the completion to
indicate this condition. For AXI, for example, the completion status is provided
by SLVERR on RRESP (Read Data channel). For PCIe, for example, the completion
status field may be set to "Unsupported Request" (UR) or "Completer Abort" (CA).

Transactions permitted by the I/O MPT Checker may still be disallowed by
additional checks outside the I/O MPT. The nature of such checks and the
handling of their violations are outside the scope of this specification.

=== I/O MPT Checker Register Interface

Each I/O MPT Checker register interface is memory-mapped starting at
an 8-byte aligned physical address and includes the registers used to configure
the the I/O MPT Checker.

[NOTE]
====
Implementations may choose to implement a coarser alignment for the start
address of the register interface. For example, some implementations may locate
the register interface within a naturally aligned 4-KiB region (a page) of
physical address space for each register interface. Coarser alignments may
enable register decoding to be implemented without a hardware adder circuit.
====

The behavior for register accesses where the address is not aligned to
the size of the access, or if the access spans multiple registers, or if the
size of the access is not 4 bytes or 8 bytes, is `UNSPECIFIED`. An aligned 4
byte access to a I/O MPT Checker register must be single-copy atomic. Whether
an 8 byte access to an I/O MPT Checker register is single-copy atomic is
`UNSPECIFIED`, and such an access may appear, internally to the I/O MPT Checker
implementation, as if two separate 4 byte accesses were performed.

[NOTE]
====
The I/O MPT Checker registers are defined in such a way that software can
perform two individual 4 byte accesses, or hardware can perform two independent
4 byte transactions resulting from an 8 byte access, to the high and low halves
of the register as long as the register semantics, with regards to side-effects,
are respected between the two software accesses, or two hardware transactions,
respectively.
====

The I/O MPT Checker registers have little-endian byte order (even for systems
where all harts are big-endian-only).

[NOTE]
====
Big-endian-configured harts that make use of I/O MPT may implement the `REV8`
byte-reversal instruction defined by the Zbb extension. If `REV8` is not
implemented, then endianness conversion may be implemented using a sequence
of instructions.
====

.I/O MPT Checker register layout
[width=100%]
[%header, cols="^3,10,^3, 18, 5"]
|===
|Offset|Name           |Size    |Description                 | Optional?
|0     |`capabilities` |4       |<<CAP, Capabilities     >>  | No
|4     |`status`       |4       |<<STS, Status           >>  | No
|8     |`control`      |4       |<<CTL, Control          >>  | No
|12    |`command`      |4       |<<CMD, Command          >>  | No
|16    |`data1`        |8       |Input/Output data 1         | No
|24    |`data2`        |8       |Input/Output data 2         | No
|===

The reset value is 0 for the following registers fields.

* `status` - `BUSY` and `CODE` fields

The reset value for `control.MODE` is recommended to be `Off`.

After a reset the MPT PTE caches in the I/O MPT Checker must have no
valid entries.

The reset value is `UNSPECIFIED` for all other registers and/or fields.

[[CAP]]
=== Capabilities (`capabilities`)

The `capabilities` register is a read-only register that holds the I/O MPT
Checker capabilities.

[caption="Register {counter:rimage}: ", reftext="Register {rimage}"]
[title="Capabilities register fields"]
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'VER'},
  {bits: 20, name: 'reserved'},
  {bits:  4, name: 'custom'}
], config:{lanes: 4, hspace:1024}}
....

The `VER` field holds the version of the specification implemented by the
I/O MPT Checker. The low nibble is used to hold the minor version of the
specification and the upper nibble is used to hold the major version of the
specification. For example, an implementation that supports version 1.0 of the
specification reports 0x10.

[[STS]]
=== Status register (`status`)

The `status` register provides the status of the operation requested using the
`command` register.

.Status Register (`status`)
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'CODE (RO)'},
  {bits: 23, name: '0'},
  {bits:  1, name: 'BUSY (RO)'}
], config:{lanes: 2, hspace:1024}}
....

When the `command` register is written, the I/O MPT Checker may perform actions
that do not complete synchronously with the write. A write to the `command`
register sets the `status.BUSY` bit to 1, indicating that I/O MPT Checker is
executing the requested operation. The behavior of writing the `command` or the
`data*` registers while the `status.BUSY` bit is 1 is `UNSPECIFIED`. Some
implementations may ignore the second write, while others may perform the
operation specified by that write. Software must verify that `BUSY` is 0 before
writing to the `control`, `command` or `data*` registers.

[NOTE]
====
An implementation that always completes the requested operation synchronously
with a write to the `command` or the `control` register may hardwire the `BUSY`
bit to 0.
====

When the `status.BUSY` bit reads 0, the operation is complete, and the
`status.CODE` field provides a status value (<<IOMPTCHK_STS>>) for the
requested operation.

[[IOMPTCHK_STS]]
.`status.CODE` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`STATUS` | Description
| 0       | Reserved.
| 1       | Operation completed successfully.
| 2       | Invalid operation (`OP`) requested.
| 3       | Operation requested for invalid `RULEID`.
| 4       | Operation requested for invalid `SDID`.
| 5       | Illegal or invalid operand encodings.
| 6-127   | Reserved for future standard use.
| 128-255 | Designated for custom use.
|===

[[CTRL]]
=== Control (`control`)

This register is used to control the operations of the I/O MPT Checker.
An implementation may allow one or more fields in the register to be
writable to support enabling or disabling the feature controlled by that
field. All I/O MPT Checkers must support the `Off` and `On` values for
the `MODE` field.

.Control Register (`control`)
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'MODE (WARL)'},
  {bits: 28, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

The I/O MPT Checker may be configured to be in the following modes:

[[IOMPTCHK_MODE]]
.I/O MPT checker modes (`MODE`)
[width=100%]
[%header, cols="16,^12,70"]
|===
| Name         | Encoding ^| Description
| Off          | 0         | No inbound memory transactions are allowed.
| Bare         | 1         | No memory protection.
| On           | 1         | I/O MPT Checker is operational.
| Reserved     | 2-13      | Reserved for future standard use.
| Custom       | 14-15     | Designated for custom use.
|===

When the `MODE` field value is changed to `Off` the I/O MPT Checker guarantees
that in-flight transactions, observed at the time of the write to this field,
from devices connected to the I/O MPT Checker will either be processed with the
configurations applicable to the old value of the `MODE` field or are aborted
<<IOMPTABORT>>. It also ensures that all transactions and previous requests from
devices that have already been processed by the I/O MPT Checker are committed to
a global ordering point such that they can be observed by all RISC-V harts,
devices, I/O MPT Checkers, and IOMMUs in the platform.

When an I/O MPT Checker is transitioned to `Off` state, the I/O MPT Checker
may retain information configured into it. The I/O MPT Checker may retain
information cached from the MPTs. Software must use suitable invalidation
commands to invalidate the cached entries. Software must initialize all SDCL
rules and SDID configurations prior to transitioning the I/O MPT Checker to `On`
state.

When the `MODE` is not `Off`, software changes to fields besides `MODE` may
cause UNSPECIFIED behavior. When the state is `On`, software must first change
the `MODE` to `Off` without changing the values of any other field.

When the `MODE` is `Bare`, the I/O MPT Checker shall request the I/O Bridge to
allow inbound transactions that are not TEE-associated and to abort those that
are TEE-associated.

A write to `control` register may require the I/O MPT Checker to perform many
operations that may not occur synchronously to the write. When a write is
observed by `control`, the `status.BUSY` bit is set to 1. When the `BUSY` bit
is 1, behavior of additional writes to `control` are UNSPECIFIED. Some
implementations may ignore the second write and others may perform the actions
determined by the second write. Software must verify that the `status.BUSY` bit
is 0 before writing to the `control` register. If the `BUSY` bit reads 0 then
the I/O MPT Checker has completed the operations associated with the previous
write to the `control` register. The value held in `status.CODE` on completing
the operations associated with a write to `control` register is UNSPECIFIED.

[[CMD]]
=== Command register (`command`)

The `command` register is used to initiate I/O MPT Checker operations. The
specific operation is identified by the `OP` field within the `command`
register. Operands required to complete the operation are supplied either in
dedicated fields of the `command` register or in one or more of the associated
`data*` registers.  The `OP` field also defines the encoding of the
`operand` fields in the `command` register and of the `data*` registers for
that operation.

.Command Register (`command`)
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits: 24, name: 'operands'},
], config:{lanes: 2, hspace:1024}}
....

[[IOMPTCHK_OP]]
.I/O MPT Checker operations (`OP`)
[width=100%]
[%header, cols="20,^12,70"]
|===
| Operation         | Encoding ^| Description
| --                | 0         | Reserved for future standard use.
| `IOFENCE`         | 1         | Ensure that all previous read and write
                                  requests from devices already processed by the
                                  I/O MPT Checker are committed to a global
                                  ordering point such that they can be observed
                                  by all RISC-V harts, IOMMUs, and devices in
                                  the system.
| `SET_SDCL_ENTRY`  | 2         | Configure a SDCL rule in the I/O MPT Checker.
| `GET_SDCL_ENTRY`  | 3         | Read the configuration of an SDCL rule.
| `SET_SDCFG_ENTRY` | 4         | Configure MPT and QoS ID parameters for an SD.
| `GET_SDCFG_ENTRY` | 5         | Read the configuration associated with an SD.
| `MPTINVAL`        | 6         | Ensure that stores to an MPT are observed by
                                  the I/O MPT Checker before subsequent implicit
                                  reads by I/O MPT Checker to the corresponding
                                  MPT.
| --                | 7â€“127     | Reserved for future standard use.
| --                | 128â€“255   | Designated for custom use.
|===

Before requesting an operation using the `command` register, software must
program the fields of the `data1` and `data2` registers as required by that
operation. Fields not used by an operation are ignored. If the `command.OP`
encoding is invalid or not supported then the operation fails with "Invalid
operation (`OP`) requested" (`status.CODE=2`). If the `SDID` or the `RULEID`
operands are invalid then the operation fails with "Operation requested for
invalid `SDID` " (`status.CODE=3`) or "Operation requested for invalid
`RULEID` " (`status.CODE=4`) respectively. If other register fields used by
the operation have an unsupported or invalid encoding then the operation
fails with "Illegal or invalid operand encodings" (`status.CODE=5`). The order
of checking the validity of `SDID`, `RULEID`, and other operands of when a valid
operation is requested operation is UNSPECIFIED.

==== Configure a SDCL rule - `SET_SDCL_ENTRY`

The `SET_SDCL_ENTRY` operation configures an SDCL rule to classify DMA requests
based on the identifiers associated with the requests, in order to determine the
supervisor domain ID (`SDID`) and the IOMMU ID (`IOMMU_ID`). The rule to be
configured is identified by `RULEID`. The `RULEID`, `IOMMU_ID`, and `SDID`
fields must contain values in the range 0 to Nâ€“1, where N is the maximum number
of the corresponding identifiers supported by the implementation.

This operation uses the operands in the `command` register and the `data1`
register. The contents of the `data2` register are ignored by this operation.

For this operation, the fields of the `command` and `data1` registers are
interpreted as follows.

.`command` register layout for `SET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  8, name: 'RULEID'},
  {bits: 16, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

.`data1` register layout for `SET_SDCL_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'SRC_IDT'},
  {bits:  2, name: 'SRC_IDM'},
  {bits:  2, name: 'TEE_FLT'},
  {bits: 24, name: 'SRC_ID'},
  {bits:  8, name: 'IOMMU_ID'},
  {bits:  6, name: 'SDID'},
  {bits: 18, name: 'reserved'}
], config:{lanes: 8, hspace:1024}}
....

The `SRC_IDT` field identifies the type of identifier from the DMA transaction
used by this classification rule. The `SRC_IDT` encodings are listed in
<<SRC_IDT>>.

[[SRC_IDT]]
.`data1.SRC_IDT` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`SRC_IDT` | Description
|    0     | None. This rule does not match any incoming transaction. All other
             fields of the `data1` register are ignored.
|    1     | Filter by device ID. The device ID is specified in `SRC_ID` field.
|    2     | Filter by PCIe IDE stream ID and PCIe segment ID. The IDE stream ID
             is specified in the bits 7:0 of the `SRC_ID` field and the segment
             ID in bits 15:8 of the `SRC_ID`. The bits 23:16 of the `SRC_ID`
             field are ignored.
|  3 - 7   | Reserved for future standard use.
|  8 - 15  | Designated for custom use.
|===

[NOTE]
====
In PCIe systems, an originating device can be pinpointed using a unique 16-bit
identifier. This identifier is a composite of the PCI bus number (8 bits),
device number (5 bits), and function number (3 bits), collectively referred to
as the routing identifier or RID. In scenarios where an IOMMU manages multiple
hierarchies, there's also an optional segment number, which can be up to 8 bits.
Each hierarchy in this context represents a distinct PCI Express I/O
interconnect topology. Here, the Configuration Space addresses, which are
delineated by the Bus, Device, and Function number tuple, remain distinct.
Sometimes, the term Hierarchy is synonymous with Segment. Especially when in
Flit Mode, the Segment number can be part of a Function's ID.
====

The `SRC_IDM` field can configure `SRC_ID` matching mode for transactions. The
`SRC_IDM` encodings are listed in <<SRC_IDM>>.

[[SRC_IDM]]
.data1.SRC_IDM field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`SRC_IDM` | Description
|    0     | Reserved for future standard use.
|    1     | TOR. If TOR (Top-Of-Range) is selected, the `SRC_ID` field
             forms the top of a range of source IDs. If rule __r__'s `SRC_IDM`
             is set to TOR, the rule matches any source ID __s__ if: __s__ is
             greater than or equal to `SRC_ID` of rule __r-1__ and is less than
             the `SRC_ID` of rule __r__. If __r__ is 0, then zero is used as the
             lower bound. If `SRC_ID` of rule __r-1__ is greater than or equal
             to that of rule __r__ and TOR is selected for rule __r__, then rule
             __r__ does not match any address.
|    2     | Unary. If Unary is selected, then this rule matches if all the bits
             of the source ID of the transaction match the value configured in
             the `SRC_ID` field.
|    3     | NAPOT. If NAPOT is selected, then the rule matches a naturally
             aligned power-of-two range of source IDs. In this mode, the lower
             bits of the `SRC_ID`, up to and including the first low-order zero
             bit, are masked; the unmasked bits are compared with the
             corresponding bits in the source ID of the transaction to match.
|===

[NOTE]
====
The following example illustrates the use of `SRC_IDM=NAPOT` when `SRC_IDT` is
by `DEVID` and a 24-bit PCIe `device_id` comprised of the segment, bus, device,
and function number is used. In the table below, `y` acts as a placeholder
representing any 1-bit value.

.`SRC_IDM` with `SRC_IDT` set to Filter by device ID
[cols="^1,3,3", options="header"]
|===
| `SRC_IDM` | `SRC_ID`                     | *Comment*
| 2         |`yyyyyyyy  yyyyyyyy  yyyyyyyy`| One specific seg:bus:dev:func
| 3         |`yyyyyyyy  yyyyyyyy  yyyyy011`| seg:bus:dev - any func
| 3         |`yyyyyyyy  yyyyyyyy  01111111`| seg:bus - any dev:func
| 3         |`yyyyyyyy  01111111  11111111`| seg - any bus:dev:func
|===

====

The `TEE_FLT` field may be used to filter transactions associated with a Trusted
Execution Environment (TEE). The encodings for the `TEE_FLT` field can be found
in <<TEE_FLT>>.

[[TEE_FLT]]
.`data1.TEE_FLT` field encodings
[width=100%]
[%header, cols="12,70"]
|===
|`TEE_FLT` | Description
|   0      | Rule matches both TEE-associated and non-TEE associated
             transactions.
|   1      | Rule matches TEE-associated transactions.
|   2      | Rule matches transactions that are not TEE associated.
|   3      | Reserved for future standard use.
|===

If filtering transactions associated with a TEE is not supported then the only
legal values for `TEE_FLT` is 0.

[NOTE]
====
PCIe IDE provides security for transactions from one Port to another. These
transactions might be initiated by contexts within the device, such as an SR-IOV
virtual function, which are associated with a Trusted Execution Environment
(TEE). Within the IDE TLP header, there's a "T" bit that helps differentiate
transactions related to a TEE. The PCIe TDISP extended TEE Extension introduces
an additional "XT" bit that complements the "T" bit. When both "T" and "XT" bit
are 0, the transaction is not related to a TEE. If either the "T" or the "XT"
bit are 1 then the transaction is related to a TEE. The `TEE_FLT` filter can be
employed to associate these TEE-related transactions with a different supervisor
domain than the transactions not related to TEE. This distinction is made even
if both types of transactions are received on the same PCIe IDE stream.
====

The `IOMMU_ID` field identifies the instance of the IOMMU that should be used to
provide address translation and protection for the transactions matching this
rule. When the I/O MPT Checker is not associated with an IOMMU, the `IOMMU_ID`
field is ignored by this operation.

If multiple rules are programmed to match a transaction, the implementation may
act based on any one of those matching rules.

If a transaction does not match any of the rules, the I/O Bridge is notified of
this condition.

==== Read the configuration of an SDCL rule - `GET_SDCL_ENTRY`

The `GET_SDCL_ENTRY` operation reads the configuration of an SDCL rule
identified by `RULEID`. This operation ignores the contents of the `data*`
registers. Upon success, the configuration of the rule identified by
`command.RULEID` is returned in the `data1` register.

The contents of the `data1` register are `UNSPECIFIED` if the operation fails
or if it is invoked without a preceding `SET_SDCL_ENTRY` for the specified
`RULEID`. The contents of the `data2` register are `UNSPECIFIED`, regardless
of whether the operation completes successfully.

The interpretation of the `command` and `data1` registers for this operation is
identical to that of the `SET_SDCL_ENTRY` operation.

When the I/O MPT Checker is not associated with an IOMMU, the value held in
`IOMMU_ID` field on successful completion of this operation is UNSPECIFIED.

==== Set Supervisor Domain Configurations - `SET_SDCFG_ENTRY`

The `SET_SDCFG_ENTRY` operation configures MPT and QoS ID parameters for a
supervisor domain in the I/O MPT Checker. This operation uses the operands in
the `command`, `data1`, and `data2` registers. The fields of these registers
are interpreted as follows.

.`command` register layout for `SET_SDCFG_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  6, name: 'SDID'},
  {bits: 18, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

.`data1` register layout for `SET_SDCFG_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits:  4, name: 'MPT_MODE'},
  {bits:  1, name: 'MBE'},
  {bits:  1, name: 'MXL'},
  {bits:  4, name: 'reserved'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'reserved'}
], config:{lanes: 4, hspace:1024}}
....

.`data2` register layout for `SET_SDCFG_ENTRY` operation
[wavedrom, , ]
....
{reg: [
  {bits: 12, name: 'S-RCID'},
  {bits:  4, name: 'reserved'},
  {bits: 12, name: 'S-MCID'},
  {bits:  4, name: 'reserved'},
  {bits:  4, name: 'SRL'},
  {bits:  4, name: 'SML'},
  {bits:  4, name: 'SQRID'},
  {bits:  1, name: 'SSRM'},
  {bits:  1, name: 'SSMM'},
  {bits: 18, name: 'reserved'}
], config:{lanes: 8, hspace:1024}}
....

The `MPT_MODE` field identifies the mode of the MPT. It's interpreted as
outlined in <<MPT_MODE_ENC-0>> when `MXL` is 0, and as detailed in
<<MPT_MODE_ENC-1>> otherwise. The implementation must support MPT
modes supported by any of the application processor harts in the system.

[[MPT_MODE_ENC-0]]
.Encodings of MPT modes when `MXL=0`
[%autowidth,float="center",align="center"]
[%header, cols="^3,^3,20"]
|===
^|Value ^| Name     ^| Description
|0       |`Bare`     | No page-based memory protection.
|1       |`Smmpt43`  | Page-based memory protection for up to 43-bit
                       physical address spaces.
|2       |`Smmpt52`  | Page-based memory protection for up to 52-bit
                       physical address spaces.
|3       |`Smmpt64`  | Page-based memory protection for up to 64-bit
                       physical address spaces.
|4-13    |-          |`_Reserved for future standard use._`
|14-15   |-          |`_Designated for custom use._`
|===

[[MPT_MODE_ENC-1]]
.Encodings of MPT modes when `MXL=1`
[%autowidth,float="center",align="center"]
[%header, cols="^3,^3,20"]
|===
^|Value ^| Name    ^| Description
|0       |`Bare`    | No page-based memory protection.
|1       |`Smmpt34` | Page-based memory protection for up to 34-bit
                      physical address spaces.
|2-13    |-         |`_Reserved for future standard use._`
|14-15   |-         |`_Designated for custom use._`
|===

The `PPN` field programs the PPN of the root page of the MPT. When `MPT_MODE`
is `Bare`, the `PPN` field must be set to zero.

The `MBE` field determines the endianness of the access made by I/O MPT
Checker to MPT configured in this entry. When this field is 0, the accesses are
performed as little-endian accesses and when 1 as big-endian accesses.

The `SRL`, `SML`, `SSRM`, `SSMM`, `S-RCID`, and `S-MCID` fields are used to
determine the effective `RCID` and `MCID` for device-originated and
IOMMU-originated requests, using the RCID-value and MCID-value provided by the
IOMMU. These fields shall be implemented if any application processor hart in
the system supports the Ssqosid extension. When implemented, they must accept
all legal values permitted for the corresponding fields in the `srmcfg`,
`mrmcfg`, and `msdcfg` CSRs of any application processor hart in the system.
If not implemented, the `data2` register value is ignored by this operation.

The determination of the effective `RCID` and `MCID` is as follows:

[listing]
----
SRL_MASK = (1 << SRL) - 1
if SSRM == 0
    effective-RCID = (S-RCID & ~SRL_MASK) | (RCID-value & SRL_MASK)
else
    if ((RCID-value & ~SRL_MASK) | SRL_MASK) != ((1 << RCIDLEN) - 1)
        effective-RCID = RCID-value
    else
        effective-RCID = <unspecified but legal value>
    endif
endif

SML_MASK = (1 << SML) - 1
if SSMM == 0
    effective-MCID = (S-MCID & ~SML_MASK) | (MCID-value & SML_MASK)
else
    if ((MCID-value & ~SML_MASK) | SML_MASK) != ((1 << MCIDLEN) - 1)
        effective-MCID = MCID-value
    else
        effective-MCID = <unspecified but legal value>
    endif
endif
----

The `SQRID` identifies the QRI for requests originating from the devices and
the IOMMU associated with the SD, and accompanies the effective `RCID` and
`MCID` in the requests made by the device or IOMMU to the QRI.

==== Get Supervisor Domain Configurations - `GET_SDCFG_ENTRY`

The `GET_SDCFG_ENTRY` operation reads the configuration of the supervisor domain
identified by `SDID` from the I/O MPT Checker. This operation ignores the
contents of the `data*` registers. Upon success, the configuration of the
supervisor domain identified by `command.SDID` is returned in the `data1` and
`data2` registers.

The contents of the `data1` and `data2` registers are `UNSPECIFIED` if the
operation fails or if it is invoked without a preceding `SET_SDCFG_ENTRY` for
the specified `SDID`.

The interpretation of the `command`, `data1`, and `data2` registers for this
operation is identical to that of the `SET_SDCFG_ENTRY` operation.

When the I/O MPT Checker does not support associating QoS IDs with requests, the
value held in the `data2` register on successful completion of this operation is
UNSPECIFIED.

==== MPT Permission Cache Invalidation - `MPTINVAL`

This operation ensures that stores to an MPT are observed by the I/O MPT
Checker before subsequent implicit reads by I/O MPT Checker to the
corresponding MPT.

This operation uses the operands in the `command` register and the `data1`
register. The contents of the `data2` register are ignored by this operation.

For this operation, the fields of the `command` and `data1` registers are
interpreted as follows.

.`command` register layout for `MPTINVAL` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits:  6, name: 'SDID'},
  {bits:  1, name: 'reserved'},
  {bits:  1, name: 'SDIDV'},
  {bits: 16, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

.`data1` register layout for `MPTINVAL` operation
[wavedrom, , ]
....
{reg: [
  {bits:  1, name: 'PPNV'},
  {bits:  1, name: 'S'},
  {bits:  8, name: 'reserved'},
  {bits: 44, name: 'PPN'},
  {bits: 10, name: 'reserved'}
], config:{lanes: 4, hspace:1024}}
....

The `PPNV` field indicates if the `PPN` field is valid and the `SDIDV` field
indicates if the `SDID` field is valid for the operation. When a field is not
valid for an operation, it is ignored by the operation. When the `PPNV` field
is 1, the `S` field sets the address range size for the `MPTINVAL` operation.
With an `S` field value of 0, the range size is 4 KiB. But, when the `S` field
has a value of 1, the `MPTINVAL` operation focuses on a NAPOT range. This range
is decided by the low-order bits of the `PPN` field, going up to the first
low-order 0 bit. If the initial low-order 0 bit position of the `PPN` field is
denoted as `x`, the size of the range is computed as `(1 << (13 + x))`.

When `PPNV` is set to 1, if the address range specified by `PPN` and `S` is
invalid, the operation may or may not be performed. If the `PPNV` and `S` are
both set to 1 and all bits of the `PPN` operand are 1, the behavior of
`MPTINVAL` operation is UNSPECIFIED.

.`MPTINVAL` operands and operations
[%autowidth,float="center",align="center"]
[%header, cols="^4,^4,20"]
|===
| `PPNV` | `SDIDV` | Operation
|   0     |  0        | Invalidates information cached from any MPT for all
                        supervisor domain address spaces.
|   0     |  1        | Invalidates information cached from the MPT for the
                        address space of the supervisor domain identified by
                        the `SDID` operand.
|   1     |  0        | Invalidates information cached from the MPT for the
                        address range in the `PPN` operand for all supervisor
                        domain address spaces.
|   1     |  1        | Invalidates information cached from the MPT for the
                        address range in the `PPN` operand for the supervisor
                        domain address space identified by the `SDID` operand.
|===


[NOTE]
====
The following example illustrates the use of `S` field to specify an address
range for the `MPTINVAL` operation. The example shows encoding ranges of up to
8 GiB. Larger ranges may be encoded using the upper address bits (bits 43:22)
of the `PPN` field.

.Examples of specifying address range sizes using `S` field
[cols="3,^1,^3", options="header"]
|===
| `PPN[21:0]`              | `S` | *Address Range Size*
| `yyyyy yyyyyyyy yyyyyyyy`|  0  | 4  KiB
| `yyyyy yyyyyyyy yyyyyyy0`|  1  | 8  KiB
| `yyyyy yyyyyyy0 11111111`|  1  | 2  MiB
| `yyy01 11111111 11111111`|  1  | 1  GiB
| `01111 11111111 11111111`|  1  | 8  GiB
|===

====


[NOTE]
====
Simpler implementations may ignore the operands of `MPTINVAL` operation and
perform a global invalidation of all information cached from any MPT.

A consequence of this specification is that an implementation may use any
information for an address that was valid in the MPT at any time since the most
recent `MPTINVAL` that subsumes that address.

Even if the I/O MPT Checker denies a request, it is allowed to cache the
corresponding MPT entry if it is valid.
====

==== I/O Fence Operation - `IOFENCE`

Ensure that all previous read and write requests from devices already processed
by I/O MPT Checker are committed to a global ordering point such that they can be
observed by all RISC-V harts, IOMMUs, and devices in the system.

The contents of the `data1` and `data2` registers are ignored by this
operation. For this operation, the fields of the `command` register are
interpreted as follows.

.`command` register layout for `IOFENCE` operation
[wavedrom, , ]
....
{reg: [
  {bits:  8, name: 'OP (WARL)'},
  {bits: 24, name: 'reserved'},
], config:{lanes: 2, hspace:1024}}
....

If a previously valid SDCL rule, and/or the supervisor domain configurations
referenced by a valid SDCL rule, are modified, then the I/O MPT Checker must
observe the new configurations within a bounded but UNSPECIFIED time. Software
may use the `IOFENCE` operation after updating the configurations. Successful
completion of an `IOFENCE` operation also guarantees that the I/O MPT Checker
has observed all configuration updates made prior to the `IOFENCE`. If the
configuration updates modify the MPT mode and/or PPN, an `MPTINVAL` operation
with `PPNV` set to 0 must be issued before the `IOFENCE`.

=== Treatment of Device-Side Address Translation Caches

Some devices may participate in the translation process and provide a
device-side ATC (DevATC) for their own memory accesses. By providing a
DevATC, the device shares the translation caching responsibility and thereby
reduces the probability of "thrashing" in the IOATC. The DevATC may be sized
by the device to suit its unique performance requirements and may also be
used to optimize DMA latency by prefetching translations. Such mechanisms
require close cooperation between the device and the IOMMU through a
protocol. For PCIe, for example, the Address Translation Services (ATS)
protocol may be used by the device to request translations to cache in the
DevATC and to synchronize it with updates made by software to address
translation data structures. +

If the IOBRIDGE and the IOMMUs support the PCIe ATS specification cite:[PCI],
the IOMMU supports two forms of transactions:

* Translated Requests
* PCIe ATS Translation Requests

PCIe ATS Translation Requests are used by the device to obtain a translation
for an I/O virtual address (IOVA) specified in the request. These translated
addresses may be cached by the device in its DevATC and used as addresses for
subsequent Translated Requests.

For a PCIe ATS Translation Request, the IOMMU performs a two-stage address
translation to determine the permissions and the size of the translation to
be provided in the completion of the request. The IOMMU may be configured to
return either the machine physical address (MPA) or a guest physical address
(GPA) (see `T2GPA` field in the Device Context, cite:[IOMMU]) as the
translation of an IOVA in the response.

Translated Requests also invoke the IOMMU to determine if the device is
authorized to use these transactions (see `EN_ATS` field in the Device Context).
When the IOMMU is configured to return a GPA in response to a PCIe ATS
Translation Request, the IOMMU translates the GPA to an MPA when invoked to
process a Translated Request.

If the IOMMU provides an Unsupported Request (UR) or a Completer Abort (CA) as
a response to a PCIe ATS Translation Request, the IOBRIDGE forwards that
response to the device. If the IOMMU provides a Success response with both
R and W permissions set to 0, it indicates that the page requested by the
Translation Request is not available, and the IOBRIDGE forwards that response
to the device. In these cases, the I/O MPT Checker is not invoked to check the
responses.

For all other responses to a PCIe ATS Translation Request, further processing
by the IOBRIDGE depends on whether the IOMMU is configured to return an MPA
or a GPA in the response.

When the IOMMU is configured to return a GPA as the translated address in
response to a PCIe ATS Translation Request, the IOBRIDGE forwards such
responses directly to the device. The I/O MPT Checker is not invoked in this
case.

When the response to a PCIe ATS Translation Request is an MPA, the IOBRIDGE
invokes the I/O MPT Checker on the entire range of translated addresses
returned by the IOMMU. If the IOMMU grants read permission to the device, the
MPT must also grant read permission; if the IOMMU grants write permission to the
device, the MPT must also grant write permission; and if the IOMMU grants
permission to execute, the MPT must also grant execute permission for the entire
range of translated addresses provided in the PCIe ATS Translation Completion.
If the I/O MPT Checker determines that the address is not accessible or that the
requested permissions are not present, the IOBRIDGE provides an Unsupported
Request (UR) response to the device. If the MPT check succeeds, the translation
completion is returned to the device.

For a Translated Request, if the IOMMU provides a UR or CA response, the
request is aborted. Otherwise, the IOBRIDGE invokes the I/O MPT Checker on the
MPA range provided by the IOMMU. If the MPT check fails, the request is aborted.
If the MPT check succeeds, the IOBRIDGE allows the request to access memory.

When protocols other than PCIe ATS are used to support a device-side ATC, the
IOBRIDGE shall apply similar rules to enforce memory protection as those
defined for PCIe ATS when implementing the I/O MPT Checker functionality.
